<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Wood Carver]]></title>
  <link href="http://woodcarver.github.io/atom.xml" rel="self"/>
  <link href="http://woodcarver.github.io/"/>
  <updated>2017-03-29T00:07:08+08:00</updated>
  <id>http://woodcarver.github.io/</id>
  <author>
    <name><![CDATA[Wood Carver]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Statistics Summary]]></title>
    <link href="http://woodcarver.github.io/blog/2017/03/27/statistics-summary/"/>
    <updated>2017-03-27T23:31:38+08:00</updated>
    <id>http://woodcarver.github.io/blog/2017/03/27/statistics-summary</id>
    <content type="html"><![CDATA[<p>前两天读了下一本书<a href="https://book.douban.com/subject/1588297/">《统计学》</a> ， 感觉这本书写的非常通俗易懂，时时刻刻都有顿悟，不仅仅知道了统计。统计学里面的量都讲的非常清楚。我这边做个小笔记把前几章的涉及到的概念都串一遍。</p>

<h1>开篇 - 平均数</h1>

<p>假如我们有一堆数，怎么才能概括呢？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>100,120,300,500,700,123,45,6,6,7,7 ...</span></code></pre></td></tr></table></div></figure>


<p>这堆数这么多，到底想说什么？能不能只给我一个指标，让我来判断？
然后，不到经过了什么，<strong>平均数</strong> 就诞生了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>100,120,300,500,700,123,45,6,6,7,7 ...
</span><span class='line'>你多了给我匀点，你少了给你添点，然后直到大家都一样了， 平均数就是那个均衡点。
</span><span class='line'>结果</span></code></pre></td></tr></table></div></figure>


<p><img src="http://woodcarver.oss-cn-shanghai.aliyuncs.com/post/absolute-mean.png" alt="mean" /></p>

<p>为什么这个值能作为衡量全局的一个指标？我想到的点如下：
1. 这是一个公平的算法，每一项都是均等的，不带任何前提假设。
2. 这是一个全局的算法，每一项都参与，不会漏掉任何一项。
3. 结果数值是可比较的，而且平均数的可比较性非常完美，直接可以和参与项做对比。</p>

<p>缺点： 就出在可比性上了，当集合是9个1和1个991， 平均数是100。这个大部分是1的情况偏差太大，已经达到不可衡量的地步。所以直接可以看出平均数是一个很容易被个项影响的指标。这也就是为什么中位数会被发明出来！当然还有衍生的4分位数。</p>

<h1>进阶 - r.m.s</h1>

<p>再谈谈平均数的问题，上面已经指出了一点，但是当数据中是有负数的时候，直接使用平均数简直就变成了灾难！比如下面是一个实验每次测量的误差数值。
<img src="http://woodcarver.oss-cn-shanghai.aliyuncs.com/post/mean-negative.png" alt="mean" /></p>

<p>结果是0，难道真的没有误差吗？显然不是。所以我们还需要想别的办法解决这个问题。如果消除掉负数的影响？在数学中我们都知识有两种方法——1. 绝对值， 2. 平方。所以在原先的方法上加入取负数影响的环节（发现统计学的设计思路和软件工程的设计思路有异曲同工之妙，都是先设计出来一个方案，遇到问题都先尝试加入层次修正，而不是直接推翻重新设计一套）</p>

<p><img src="http://woodcarver.oss-cn-shanghai.aliyuncs.com/post/absolute-mean.png" alt="absolute-mean" />
<img src="http://woodcarver.oss-cn-shanghai.aliyuncs.com/post/square-mean.png" alt="square-mean" /></p>

<p>不知道你在统计学中发现没有，很少用绝对值算子，其实如果你想想编程就会很清楚为什么会这样。原因很简单就是绝对值操作起来比平方要麻烦。看下面两端代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c"># absolute value</span>
</span><span class='line'><span class="k">if</span> <span class="n">num</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
</span><span class='line'>  <span class="n">num</span> <span class="o">=</span> <span class="n">num</span>
</span><span class='line'><span class="k">else</span><span class="p">:</span>
</span><span class='line'>  <span class="n">num</span> <span class="o">=</span> <span class="o">-</span><span class="n">num</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c"># square</span>
</span><span class='line'><span class="n">num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">*</span> <span class="n">num</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是如果用square又有一个问题，那就是可比较性差了，结果值比原来的数据项都要平方了，有点失真，不完美！
所以人们又要在原来的解决方案上加上一个开方，让差距拉回来。</p>

<p><img src="http://woodcarver.oss-cn-shanghai.aliyuncs.com/post/square-mean-root.png" alt="absolute-mean-root" /></p>

<p>而且还为了这种组合方案打了个包，形成了固定说法r.m.s (square mean root)。
<img src="http://woodcarver.oss-cn-shanghai.aliyuncs.com/post/rms.png" alt="rms" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Data Visualization - D3js]]></title>
    <link href="http://woodcarver.github.io/blog/2017/02/24/data-visualization-d3js/"/>
    <updated>2017-02-24T23:54:12+08:00</updated>
    <id>http://woodcarver.github.io/blog/2017/02/24/data-visualization-d3js</id>
    <content type="html"><![CDATA[<h1>d3js的设计之美</h1>

<p>世界上有许多美丽的软件，而d3js是最美之一，在我心中在前端技术中是最美的。</p>

<p>不用多说，d3js是一款构建数据可视化的框架，其中最主要的编程思想就是数据驱动，但是这个框架为什么这么美，让我慢慢道来，当然还需要分好几个步骤道来。
首先我们定义下美的标准是什么。我会认为俄罗斯方块是美的，数独是美的，特别是二进制是极美的……他们的共同特点是什么呢？
1. 其实状态非常少
2. 规则非常简单，且直白明了
3. 通过搭配简单基础的规则，衍生出极其丰富的上层建筑
4. 其中充满了各种“巧合”和令人惊讶的“复杂”，看起来浅显易懂，但是又出人所料！</p>

<p>d3js规定的比较少的接口，并且分好了类，非常直观的同时又非常便于查询和联想，一个好的框架或者系统能在你使用它的一部分后，剩余的部分通过前面的使用经验能很容易的猜想出来。而大部分框架提供的繁杂的使用，则是关系甚少，需要不断耗费精力去穷尽其文档。当然最糟糕的是连文档都不全，只能趴源码看！</p>

<p>所以好的框架是一定想清楚了使用的日常使用方式，然后设计出来的一套极简规则。</p>

<p>先让我们看看d3js的接口吧！d3js接口大致分7类：</p>

<ol>
<li>核心 - 包括选择器，过渡，数据处理，本地化，颜色等。</li>
<li>地理 - 球面坐标，经纬度运算。</li>
<li>几何 - 提供绘制2D几何图形的实用工具。</li>
<li>布局 - 推导定位元素的辅助数据。</li>
<li>比例尺 - 数据编码和视觉编码之间转换。</li>
<li>可缩放矢量图形 - 提供用于创建可伸缩矢量图形的实用工具。</li>
<li>时间 - 解析或格式化时间，计算日历的时间间隔等。</li>
<li>行为 - 可重用交互行为</li>
</ol>


<p>所以d3js的开发步骤，仅仅是抓住下面几个关键步骤：</p>

<ol>
<li>构建想要图的所要的坐标和数据。比如你要构建一个二叉树，那么你根据输入，把坐标数据先计算好。
根据输入信息得出坐标信息，复杂常用的算法都已经在d3中实现，包涵在d3.layout包下面。比如：<a href="https://github.com/d3/d3/wiki/%E6%A0%91%E5%B8%83%E5%B1%80">Tree</a>输出整齐地排列树节点，<a href="https://github.com/d3/d3/wiki/%E5%88%86%E5%8C%BA%E5%B8%83%E5%B1%80">Partition</a> 输出递归地将节点树分割为旭日状或者冰柱状。
其余的layout文档，请点击<a href="https://github.com/d3/d3/wiki/%E5%B8%83%E5%B1%80">这里</a> </li>
<li><p>根据上一步计算结果，画出你想要的。这一步需要借助d3的核心API来操作DOM，可以是HTML、SVG、CSS等。特别说明一点是d3封装了很多常见基础的SVG组件，你不必什么时候都操作裸SVG节点。既然是dsjs，那么封装的也是非常优美，有章可循的：</p></li>
<li><p>添加响应交互事件。比如点击、hover等js标准事件。</p></li>
</ol>


<p>上面的1，2步骤</p>

<h2>谈谈数据驱动编程</h2>

<p>什么是数据驱动？stackoverflow上的答案一个回答：</p>

<blockquote><p>Data driven progamming is a programming model where the data itself controls the flow of the program and not the program logic. It is a model where you control the flow by offering different data sets to the program where the program logic is some generic form of flow or of state-changes.</p></blockquote>

<p>数据驱动编程的对立面是什么？ —— 我给的答案是规则编程。</p>

<p>数据驱动有什么好处？数据驱动的思想的基础：</p>

<ol>
<li>输入是不确定性，所以结果也是千变万化的。</li>
<li>为了适应输入的不确定，规则需要由数据制定。相反的首先制定规则，即规则驱动编程。其思想是假定规则是确定的，输入也是不多变的，所以先制定几个规则，让数据灌进来即可。这种编程的弊端就是，程序比较僵硬，当数据表现的不符合先前的假设，那么程序将出现异常。扩展性也很差，因为需要给每种异常来扩展相应的规则。到最后就形成了一堆堆砌的丑陋的if或者switch条件了。</li>
</ol>


<p>说的这么多，先举个例子。看看怎么把代码逻辑转移到数据中。
比如消息发送程序，如果是规则编程可能是这样的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="kd">function</span> <span class="nx">msgProc</span><span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;num1&quot;</span> <span class="o">==</span> <span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">count</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;type1&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;num2&quot;</span> <span class="o">==</span> <span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;type2&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;num3&quot;</span> <span class="o">==</span> <span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">type</span> <span class="o">+</span> <span class="s2">&quot; = type3&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;num4&quot;</span> <span class="o">==</span> <span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;type4&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;other&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码是纯粹的规则编码，当遇到更多的规则的时候就不断增加if的个数。根本没办法做到扩展优先，修改原有代码第二的原则。这样每次修改代码都需要全部回归测试，原来的系统面临的风险也很大。特别是当这个函数是第三方代码或者别人的代码库，想要加规则更加困难。但是如果变成数据驱动，代码会如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="c1">// data here</span>
</span><span class='line'><span class="nx">msgProcData</span> <span class="o">=</span> <span class="p">[</span>
</span><span class='line'>  <span class="p">[</span><span class="s2">&quot;num1&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span> <span class="nx">count</span><span class="o">++</span><span class="p">;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">count</span> <span class="o">+</span> <span class="s2">&quot; = type1&quot;</span><span class="p">);</span> <span class="p">}],</span>
</span><span class='line'>  <span class="p">[</span><span class="s2">&quot;num2&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;type2&quot;</span><span class="p">);</span> <span class="p">}],</span>
</span><span class='line'>  <span class="p">[</span><span class="s2">&quot;num3&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">type</span> <span class="o">+</span> <span class="s2">&quot; = type3&quot;</span><span class="p">);</span> <span class="p">}],</span>
</span><span class='line'>  <span class="p">[</span><span class="s2">&quot;num4&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;type4&quot;</span><span class="p">);</span> <span class="p">}]</span>
</span><span class='line'><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="kd">function</span> <span class="nx">msgProc</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">msgProcData</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span><span class="o">=</span> <span class="nx">msgProcData</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nx">msgProcData</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span>  <span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">msgProcData</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">](</span><span class="nx">type</span><span class="p">);</span>
</span><span class='line'>      <span class="k">return</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;other&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>隐含在背后的思想：</p>

<ol>
<li>更容易修改，要增加新的消息，只要修改数据即可，不需要修改流程。</li>
<li>隔离变化。像上面的例子，每个消息处理的逻辑是不变的，但是消息可能是变化的，那就把容易变化的消息和不容易变化的逻辑分离。</li>
<li>控制复杂度。通过把程序逻辑的复杂度转移到人类更容易处理的数据中来，从而达到控制复杂度的目标。</li>
</ol>


<p>另一个更加有趣的例子，状态机的编写：[todo]</p>

<p>推荐两本说明数据驱动编程的书，一本是《Unix编程艺术》，其中提到各种编程思想的，是程序员必读书本之一，且是需要反复研读。第二本是吴军的新书《智能时代》，其中的第三章，思维的革命中的提到的机械思维到数据驱动转变。编程设计思维也是一样的。我们大多数编程的时候其实应用的都是机械思维。总认为输入是情况就那么几种，且也是静态的，从而忽视和扩展性的重要。而当使用数据驱动编程的时候，我们就会先想整个骨骼框架是什么，然后在想每种数据下，具体的逻辑该是什么。这样就延迟了数据处理的逻辑，并且达到了一种可变部分的隔离效果。</p>

<h1>Reference</h1>

<ul>
<li><a href="https://github.com/d3/d3/wiki/Tutorials">dsjs Tutorials</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ctr]]></title>
    <link href="http://woodcarver.github.io/blog/2016/11/13/ctr/"/>
    <updated>2016-11-13T19:49:52+08:00</updated>
    <id>http://woodcarver.github.io/blog/2016/11/13/ctr</id>
    <content type="html"><![CDATA[<h1>ctr模型预估</h1>

<h2>Logistic Regression</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Computational Advertising]]></title>
    <link href="http://woodcarver.github.io/blog/2016/11/06/computational-advertising/"/>
    <updated>2016-11-06T21:43:30+08:00</updated>
    <id>http://woodcarver.github.io/blog/2016/11/06/computational-advertising</id>
    <content type="html"><![CDATA[<p>刘鹏表示，不了解计算广告，就不可能深入地了解互联网，也不太容易真正理解大数据。技术从业者需要从行业、宏观的角度认识这个领域，进而掌握相应的思考方法和技术，包括<strong>商业产品的思路和工作方法，信息检索、机器学习、最优化、博弈论等基础数学工具，以及Hadoop、Spark和其他开源工具为核心的大数据基础设施</strong>等。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Power of Infomation and Time]]></title>
    <link href="http://woodcarver.github.io/blog/2016/10/24/the-power-of-infomation-and-time/"/>
    <updated>2016-10-24T13:32:56+08:00</updated>
    <id>http://woodcarver.github.io/blog/2016/10/24/the-power-of-infomation-and-time</id>
    <content type="html"><![CDATA[<h2>一个懒惰就白白浪费1500元</h2>

<p>这真实一个愚蠢的教训，人总是不断的钻牛角尖的方式去提高自己的月薪，但是却容易忽视自己生活中的各种犯懒而导致的远远超过自己辛辛苦苦劳动力的价格。
比如我再2016-10-24号发生的自如退租的事情。如果我提前30天解约，只损失70%的押金，提前20天，只损失100%押金，小于20天，而除了押金全陪还要搭上补齐20天房租的钱。我是提前6天提出解决的，这让我损失了1747元，这比钱是我一年买书的钱，一年中请朋友吃饭的钱，两年买衣服的钱，五年看电影的钱。而这笔钱我完全就留心，一个提前的电话就可以搞定。这件事情让我意识到了信息和时间的力量，这才是杠杆最大的赚钱资本。</p>

<p>相比我一天的工资，这就相当于我好几天是白干的！</p>

<p>当然让我白干的事情还有很多很多，比如对自己财产的放任不管的处理方式（V-V），放在银行里让其贬值。但是如何预防这种事情呢？我为什么空不出足够的精力去增加自己的财产性收入呢？想了想这才是我最大的问题，为什么我的行为会如此愚蠢，为什么我会“放任金钱”从手中流失？</p>

<p>难道是我不喜欢这些事情吗？（嗯，我确实不喜欢！）但是我想更多的应该是没有习惯这种全局的思考，人生有想要保持简单，还是先要把地基打牢固才行。</p>

<p>看来除了信息和时间的力量，最强大的还会自己管理注意力的力量。请把精力放在杠杆大的地方！想想《狼与辛香料》关于货币那章节，还有想想房价的时效性。果然同意劳动是最没有杠杆的赚钱方式，应该腾出时间，腾出精力去想想这些生活方面的！</p>

<p>交学费要有价值才行，不然就是学费，而是挥霍！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning How to Learn]]></title>
    <link href="http://woodcarver.github.io/blog/2016/09/14/learning-how-to-learn/"/>
    <updated>2016-09-14T16:40:30+08:00</updated>
    <id>http://woodcarver.github.io/blog/2016/09/14/learning-how-to-learn</id>
    <content type="html"><![CDATA[<p>《Learning how to learn》是一门coursera上一门优秀的课程，已经开播很多期。我在这里开始把这门课程以自己的方式翻译成中文版。希望能给大家带来一些学习方法上的收获，提升大家的学习效率。</p>

<h1>第一章： 大脑中的两种思维方式——聚焦式（focused modes）和发散式（Diffuse modes）</h1>

<p>当你想不出来一个问题的答案时候你会怎么做？对于僵尸来说，那可件简单的事情。他们可以通过不断的把脑袋往墙上撞就可以了。但是活着的大脑则是相当复杂的。事实表明，如果你能多了解一点大脑的工作过程，你将会把学习变得轻松很多，同事少很多挫败感。</p>

<p>万能的研究人员发现我们人类大脑一般有两种思考方式，一种是聚焦式思考方式，另一种是发散式思考方式。
我们非常熟悉聚焦式思考方式，这种方式是通过集中注意力在正在学习和理解的东西上。但是我们不太熟悉发散式方式，这种方式是通过关联一组正在休息的神经元细胞。</p>

<p>我们将通过一个<strong>弹球游戏(pinball game)</strong>的打比来让大家理解这两种思考方式。顺便说
一下，象征和比喻是一种强大的工具来让我们理解一些要学习的东西。</p>

<p><img src="http://woodcarver.oss-cn-shanghai.aliyuncs.com/post/learning_how_to_learn/pinball.png" alt="pinball" /></p>

<p>pinball的内部则充满着小柱子，这个游戏的基本规则是你通过拨动一个弹簧然后射出一个小球，使它达到目的地小柱子上。现在到你的大脑，你的眼睛在前面，耳朵在两旁，然后你的大脑就是pinball内部结构。</p>

<p>下面的图是focused mode的比喻：
<img src="http://woodcarver.oss-cn-shanghai.aliyuncs.com/post/learning_how_to_learn/focused_mode.png" alt="focused mode" /></p>

<p>我们发现其有一些线已经连通了一些柱子，而且这些柱子之间的距离都非常近。看着图中的橘黄色的线，它就代表着一个熟悉的思考模式，也许代表着简单的加法。你在想一些事情，小球就会从底部的小点出发，移动到大脑的里面，然后开始搜索，如果到了小蓝柱子之间有橘黄色连线的时候，思考是非常容易的，因为每个柱子之间距离非常近，还有现成的连线可以达到。</p>

<p>这是一个相当愉快的又熟悉的过程。但是如果我们要到一个熟悉的地方怎么办？比如我们要获得一个新的想法（idea）或者一个新的方法的时候。你既不知道它在哪里，也不知道它长什么样子。例如下图：
<img src="http://woodcarver.oss-cn-shanghai.aliyuncs.com/post/learning_how_to_learn/how_to_reach_new_things.png" alt="how_to_reach_new_things.png" /></p>

<p><strong>你怎么到达下面的绿色连线的部分？</strong></p>

<p>这就是一个典型的如果你要获得什么东西，你首先需要创建它。而通常创建东西的方法和使用东西的方法不一样。这时候就引出了发散式思维方式。
<img src="http://woodcarver.oss-cn-shanghai.aliyuncs.com/post/learning_how_to_learn/different_in_diffuse_mode.png" alt="different_in_diffuse_mode.png" /></p>

<p>我们看到在这种思维下，你看问题的方式会非常不一样。小球会要穿越非常长的距离，而且跨越的范围也非常大。在你的大脑里，你可以创建新的神经元模式在移动小球的过程中。在diffuse mode里面，你思考问题非常广泛。这时候你不能把注意力集中在一起，反而是一种全图景象（big-picture）的过程。这种思考方式不是让你得到一个问题的答案，但是可以至少给你一个解决方案的粗糙的原始方案。</p>

<p>现在神经学科学家发现，你不可能同时处于两种思考模式，而是只能选择其一。这就像一个硬币，要么翻到正面，要么翻到反面，但是不可能两面同时出现。</p>

<p>接下来让我们看看一些名人是怎么学习的。Salvador Dali 一名20世纪非常有名的画家，他被认为是一个非常狂野和疯癫的人。Dali曾经对一个项能提升他绘画效果的技能非常痴迷。这时候他会懒懒的坐在椅子上然后放任的大脑，只是略想想之前集中想的事情。他手里会拿把钥匙，当他快要睡着的时候，钥匙掉在地上发出的响声会吵醒他。紧接着之后他就可收集下刚才的在diffuse mode下的想到的线索和东西，然后开始进入foucsed mode。</p>

<p>也许你会说这种方式只适合于艺术家，但是Thomas Edison（爱迪生），世界上最有名的科学家也使用同样的方法。Edison遇到了一些难题的时候或者新东西，会放松的坐在椅子上，然后手里塞满滚珠，然后开始放松大脑，只是是不是的返回自己刚才专注的事情。当自己快要打瞌睡的时候，滚珠就掉下来。自己被滚珠砸在地上的声音弄醒，然后开始回想刚才在放松的情况下的线索回到集中注意力状态。</p>

<p>所以从上面的过程看来学习一项新东西，你需要在两种思考模式之间来回切换，这样会帮助你有效的学习。这就像你通过举重来锻炼肌肉一样，你不会把所有的锻炼都在一天内做完，相反你会每天锻炼一点。渐渐的肌肉就会长起来。大脑的神经元细胞同样也需要每天锻炼。</p>

<p>了解两种不同的思维方式，后面的课程会介绍怎么<strong>正确</strong>的这两种思考方式来达到最好的学习效果。</p>

<h1>第二章: 拖延症，记忆和睡眠</h1>

<h2>拖延症</h2>

<p>每个人都有拖延症。因为如果你正在做某一项工作时候，这意味着你不能干其他事情。有些人的症状要比另一些人严重，我们在这里会详细讨论拖延症的产生原因，还会给出一些很有用的工具来帮你克服它。</p>

<p>当你不情愿的看着某些东西的时候，这似乎意味着你大脑和痛苦相关的区域正在活跃着。你的大脑，很自然的会倾向于通过转移注意力来停止这种负面情绪。但是这是陷阱。研究人员<strong>发现当人们开始做他们不喜欢的事情时间不久之后不舒服感就会消失</strong>（关键还是要开始做呀！）。这就是你在拖延时候发生的情况。首先，你观察然后得到一个因为某个东西引起的不适的暗示，你不喜欢他，所以你开始转移注意力以此来消除这种因为某些原因引起的不适的感觉。</p>

<p>你会转向某些轻松的事情。结果就是你会<strong>暂时的</strong>感觉到快乐。我们会在后面讨论更多关于拖延的知识。此时我们给出一个克服拖延的工具 —— Pomodoro（番茄时间规划法）。这是一种非常简单的方法，需要的道具只有一个定时器就够了。它把时间化成块，有学习块和休息块。一般一个学习块是25分钟，一个休息块是5分钟。一个学习块加上一个休息块成为一个番茄。具体过程是你首先计划做的事情需要多少时间完成，然后分配给番茄。然后一个番茄一个番茄的做完。（具体建议还是看下《番茄工作法图解》的具体细节）</p>

<p>关键动作：<code>强迫自己做，然后就会顺其自然</code></p>

<h2>记忆</h2>

<p>当我们回忆童年往事的时候，我们是直接从大脑的长期记忆部分取出内容。但是当我们试图理解一个新问题或新概念的时候，我们是先把一些想法放在心中，这是利用工作记忆（短期记忆）。很显然，有时候我们会把长期记忆取出然后放入工作记忆中，这样就可以对它进行思考了。所有这两种记忆是有联系的。</p>

<p>有很多种划分记忆的方法，但是在这里，我们只用两种主要的记忆系统—— 工作记忆（短期记忆，可类比入计算机的内存）和长期记忆（可类比计算机的磁盘）。工作记忆是记忆中承担立刻和有意识的过程部分。研究者过去认为我们的工作记忆大概可以保存7个物品或者事件，但是现在认为只能是大概4个信息块。我们倾向去自动把要记忆的东西<strong>分组</strong>，所以我们的工作记忆实际上可以比我们认为的要大。</p>

<p>尽管你的工作记忆就像一块黑板一样，它其实是一块不怎么好的黑板。你经常需要不断的重复才能把要记忆的东西保留在工作记忆上。举个例子，你要写下以电话号码之前你需要重复好几遍。你应该会发现当你闭眼想要集中注意力的时候总会有别的事情来侵占你工作记忆中有限的槽位（4个）。因此我们知道了短期记忆是一个不怎么有效的黑板。另一种记忆系统——长期记忆，有点像是记忆仓库（看过《头脑特工》的读者们应该会很有画面感）。它分布在大脑的各个地方并且占有很大的面积。不同的长期记忆被储存在不同的地方。研究者表明，如果你想把一个短期记忆（比如一个数学公式）储存进长期记忆中，你至少需要重复几遍来增加以后需要时成功获取的概率。长期记忆的储存量是无限的，它有空间来存放数亿的东西。实际上，在长期记忆中记忆和记忆之间可能会发生互相覆盖，所以除非你练习和重复几次，否则很难找到想要的信息。</p>

<p>长期记忆非常重要，因为它储存着你学习时需要的基础概念和技术。当你尝试新东西的时候，你经常需要使用工作记忆来承载这些知识。如果你想把信息从长期记忆中加载到工作记忆中，你还需要练习几遍才行才能熟练这种获取过程。当然重复也有技巧，就是<strong>不要一共100个单词，一天重复一个单词100遍。而是单词分摊开，一天记忆一遍所有单词，第二天依然，持续100天</strong>。所以记忆一个东西，一个下午重复7次，不如每天重复一次来的效果好。把记忆的过程想象成使用胶水，大脑内部的神经元细胞之间需要时间来建立连接，就想胶水需要时间类风干一样。</p>

<p>关键动作：<code>每天重复一点</code></p>

<h2>睡眠</h2>

<p>你也许会惊讶当你知道人醒着的时候我们的大脑会产生毒素！大脑是怎么排除这些毒素的呢？结果是当你睡觉的时候，你的大脑细胞会缩小，然后细胞之间的空隙会变大，这时候液体可以流过这些细胞进而把毒素清洗出去。所以睡眠，在某种意义上来书就是清洗的时间，是大脑保证自身的卫生和健康的方法。所以让我指出关键点，没有休息好就去考试时候，意味着你运行这一个充满神经毒素的大脑。毒素会让你思考不再那么清洗和快速。</p>

<p>睡眠还有另外一个好处，就是在你睡觉的时候，大脑会重复清醒的时候的知识，加强记忆和连接。所以睡眠并不是浪费时间，当然前提是你已经先尝试集中式思考后播下了进行发散式思考的种子。</p>

<p>当你在睡觉以前学习了一些知识，你有很大概率梦见他们。梦见这些东西能提高你理解它们的概率。</p>

<p>关键动作： <code>睡眠</code></p>

<h1>第三章: Chunking &ndash; The Essentials</h1>

<p>这一章讲到了具体的学习方法。首先还是需要搞清楚我们的大脑到底是怎么运作的。上一章只讲了几了两种基本模式，这一章会继续深入——知识的基石块（Chunking）。这一章从学习的质量入手。首先讲到什么是<strong>学习完成幻想症（Illusions of competence in learning）</strong>，第二个大问题是<strong>过度学习（over learning）</strong>。</p>

<h2>什么是思维块（Chunk）？</h2>

<p>首先我们先学习个英文单词——chunk。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>chunk |tʃʌŋk|
</span><span class='line'>noun
</span><span class='line'>①(piece of meat, fruit, bread, etc.)大块
</span><span class='line'>a chunk of plaster
</span><span class='line'>一块厚厚的灰泥
</span><span class='line'>②colloquial (large amount)相当大的量
</span><span class='line'>a fair chunk of the essay
</span><span class='line'>文章的大部分</span></code></pre></td></tr></table></div></figure>


<p>我们来是拿学习一个新概念为例，一般来说当我们接触一些不熟悉的时候，第一反应这些是“什么东西，完全没有感觉呀！”。这些知识点就像一堆散乱的拼图碎块一样，完全意识不到他们拼接起来后会是一幅完整的图画。</p>

<p><img src="" alt="big_picture" /></p>

<p>Chunking就是一种思维跳跃的过程，它可以帮助你把一些信息有条理的聚合起来。新的逻辑会让这些碎片容易理解，更重要的是能把它们联系起来形成一张更大的图片。仅仅记忆一些事实，而不是理解其中上下文不能帮助你理解你正在学习的东西，也不能帮助你理解这些概念和其他概念是怎么联系起来的。注意到这里这块碎片不能和那块相扣，可以帮助你找到其他的碎片是否和这块相扣。</p>

<p>我们前面谈论过我们的短期记忆一般只能记住4件东西。当你集中注意力的时候，就像头顶上有个章鱼，章鱼的有4个触须通过这4个孔来帮助你把分散在大脑各个部分的信息给连接起来。</p>

<p>记住，这和发散式思维中的随机连接是不一样的。集中注意力并尝试去把大脑中的各个部分连接成一个想法是集中式思考学习方法的一个重要组成部分。这也是常用的帮助你建立一个chunck的方法。有趣的是当你处于压制注意力的情况下，脑前的章鱼就开始丧失了连接信息的能力。<strong>这也就是为什么当你处在愤怒、压力或者害怕的时候，大脑不能高效工作的原因。</strong></p>

<p>chunk是一些信息的有机的结合起来形成一个有意义有用的更大片段。比如你可以认识并说出P、O、P这三个字母，并且把他们结合起来形成另外一个有意义的单词pop。这就是一个chunking的过程。</p>

<p>最好的学习语言方式是在集中注意力的状况下的不断重复练习和记忆，同时搭配上自由式的以此语言为母语的朋友对话练习。这样做的目的就是把基本的单词和语法嵌入到脑中，同时放松自由的使用此门语言来创造你自己新语言模块。集中注意力在练习和重复上面，会创造更强的记忆痕迹，这样帮助你创造更多的chunks。通往专家的路是一点一点来的，小的chunks会逐渐变大变成一门专长，并且所有的专长会成为对你成为一名掌握某种本质的大师的基石。总而言之，就像你稍后会看到的，练习和重复的建造chunks并不是你成为某一技能大师的全部，Chunking会帮助你的大脑运转的更加有效。一旦你形成了一个想法，一个概念或者一个动作，你就不需要再记住原来的那些细小的细节了。你已经得到了主题思想——块，那就是足够了。</p>

<p>举个例子，比如你早晨起来穿衣服。你会觉得这是一件很简单的事情。但是出人意料的是当你意识到影藏在这个简单地动作下的一系列活动。</p>

<h2>如何形成chunk？</h2>

<p>我们现在先来介绍一点怎么形成chunk的背景知识。假如你想学习用吉他弹奏一首曲子，而相应的大脑中的神经元表征是一块相当大的块。你会先听这首歌，也许你还会看别人演奏这首曲子，特别是当你还是为初学者的时候，你会学会怎么抱吉他。对于大多数项目和技能来说，获得一个对掌握东西的大体印象的步骤都是相似的。你经常首先抓住一定曲子的片段，并形成一个微小块(mini-chunks)，这个微小块以后会和其他块连接起来形成大块。例如，经过好几天后，你或许已经学会了使用吉他熟练的弹奏一个乐段，而当你掌握很多乐段后，你可以将这些乐段连接起来，逐渐的把所有的段放在一起后你就学会了这首曲子了。</p>

<p>对于学习运动，比如篮球，足球，高尔夫。你先掌握和练习几个片段必要的技能点。这时候你就是在建立微小块，这些微小块日后会渐渐连接成大块，再后你就可以使用这些大块再形成更大、更复杂的块，之后你可以立即使用这些巨大块。比如你可以在踢足球时使用停球技巧，控制朝你轻轻旋转滚来的足球。最好的组块是那些根深蒂固的，你甚至不需要有意识地去将储存在脑中的模式连接起来。而这也正是将复杂的想法，动作和反应，组成一个单独的组块的意义所在。你可以在学习语言时体会到这点，最开始说的一个简单单词，其中的细微差别，语调和口音就已经需要很多的练习了。即兴造句需要有创造力地将新语言中各种复杂的小组块和较大组块联系起来。为了清晰地表达我的意思，试着重复印度卡纳达语的绕口令吧。</p>

<p>Hi，我是Shilpa Knokani。 我的母语是Kannada，这是一种印度最古老的语言之一。今天我们教你一个Kannada的绕口令，来更我读：“Terikere yri male muru kari kurimari meyuthiddavu”。是不是特别简单？（！！！非母语的我们实际表情）。看来除非你是当地人，否则语言只能一点一点学习。</p>

<p>学习数学和科学涉及到同样的方法。当你学习一个新数学或者科学知识时候，通常会先给你一些简单的问题并且附上解答过程。这是因为当你首次尝试理解怎么解答一个问题的时候，你的大脑会产生称重的认知负担。所以这些例子会帮助你起步。这就像你需要先听一首歌然后才能弹奏这首曲子。大多数的解答细节都在这里，而你的工作仅仅是找出到达目的地的路而已。这些例子可以帮助你看清楚问题的关键特征和隐藏的本质。</p>

<p>在使用示例帮助你形成chunks的过程中需要注意一点，那就是这种方法太容易让你集中在一个单独的步骤而不是步骤之间的联系上。这就是为什么下一步你一定要做的关键步骤。所以请铭记于心，这里并没有仅仅教授你“按部就班的做”，仅仅接受指示而不加思考。实际上学习的过程应该更像是使用一张地图来帮你到达一个新地方。集中注意力在将要去的下一个地方，很快你就会找到你自己想要到达的目的地。你甚至可以找出另一条新路径。</p>

<p><strong>接下来我们进入实战环节——形成chunk的具体操作步骤：</strong></p>

<ol>
<li>不要分散注意力，要全神贯注到要关心的事情上</li>
</ol>


<p>不要分散注意力指的是当你开着电视写着作业，或者隔几分钟查看下手机，这样是会大大增加chunk形成的难度。因为你的大脑并没有真正的聚焦在要学习的东西上。当你首次学习某些东西，你正在努力产生一个新模式，这个模式会连接分布在大脑各个地方的已经存在的模式。从前面的关于记忆的章节我们知道，我们的暂存工作空间平均只有4个槽位，所以当你分散精力的时候会占用这些槽。</p>

<ol>
<li>理解基础的思想，不仅仅是独立的块知识，还有这些块之间的<strong>联系</strong>。</li>
</ol>


<p>联系是非常重要的，我们是不是经常有这种感觉，背了无数的英文单词，但是发现确没有办法把他们使用在对话或者写作中？这就是缺少理解他们联系的典型表现。</p>

<p>而且为使得你真正理解所学的内容，请做<strong>练习</strong>。比如你学习一些科学知识的时候，请合上书然后做一些测试。这样会帮你理解问题，同时也会加快你学习的步伐。当你能动手自己做的时候才是你真正理解这些知识的时候。而如果你只是看过，听过，而没有实际做过，就不要指望能真正的吸收容纳成自己的。因为仅仅看过，过着认为自己理解了，并不意味着你可以自己做出来。这个方面我们后面还会涉及，并且有个专业名词——完成幻想。</p>

<p>练习就是帮助你打破这些知识孤岛，把他们联系起来的一个很有效的方法。它会真正的帮你建立chunk之间的联系路径。学习的有梁祝基本的方式——从上到下的方式，从下到上的方式。从下到上的方式指的是你首先学会一些独立的基本块知识，不断的练习知道熟练，并且在需要时候能够轻易使用。然后在尝试着把这些知识都联系起来，形成更多样的用法。比如你学习一首曲子，应该是一个段落一个段落的练习，然后把各个段落连接起来，形成一首完整的歌。而从上到下的学习方式是你首先基本感受一下这方面的整体蓝图。弄清楚它到底有什么用，适用于那些地方。</p>

<p>所以一个基本的学习方法是：在要学习之前首先浏览下整个章节，大概看下要讲什么内容，每个小节会涉及到什么。这样可以帮助你弄清楚知识的基本的概要。就想有了一个大概的地图，让你能很好地组织后面学习的进行。</p>

<p>如果用神经科学的角度来讲，这种方法可以帮助你了解你需要把构建的chunks放在哪里，各个chunk之间有什么关系。</p>

<p>学习某些知识时候，一般都会有关键指示或者书目，或者概念索引等概要知识。你把这些东西找出来后，再往里面填充细节。尽管有些地方可以会被漏掉，你仍然可以知道整个全景是什么样子的。总结起来就是chunks最好在聚精会神、理解基础思想的时候形成。同时练习可以帮助你抓住中心思想。</p>

<p>这就是形成chunk的主要步骤了。</p>

<h2>知识获得假象（Illusions of Competence）</h2>

<p>这章节的内容非常实用，犀利的指出了我们的<strong>无效学习</strong>。这个章节的内容：</p>

<ul>
<li>回放（Recall）</li>
<li>Illusions of Competence</li>
<li>Mini-testing</li>
<li>Value of making mistakes</li>
</ul>


<p>一种常见的学习方法就是重复的读书本和笔记知识。但是根据心理学家——Jeffrey Karpicke表明这种方法通常笔记另一种简单、实用方法低效很多。而这种方法就是<strong>回放（Recall）</strong>，具体指当你读完一段材料后，不要急着读第二遍，而是把书合上是回忆刚才的所读的信息（最好能在纸上画一个大概的结构地图，或者脑图）。</p>

<p>Karpicke的研究发表在《科学旅程》杂志上面，其中有明显的证据表明这种方法非常可行。实验中学生们被要求先学习一段科学知识，然后做些记忆回访练习。这种动作往复几遍。同时对照组使用其他的学习方法，比如简单的重复读一遍内容，之后的测验结果表明回放的学习方法效果大大好于其他的方法。</p>

<p>当我们在脑中检索知识的时候并不是知识简单的回忆机器而已。这个检索过程本身就能提高学习程序，并且帮助我们开始形成chunks。这种就和回忆一样能帮助我们建立微小的神经元挂钩一样，我们可以把（ It&rsquo;s almost as if the recall process helps build in little neural hooks, that we can hang our thinking on.
？？？）</p>

<p>令研究者更惊讶的是学生们简单读后做回忆联系这种方法并不是最好的方法。更好的学习方法是合上书本后尝试画出关键知识路径图，弄清楚各个部分的关系。但是这种方法的前提是你已经把基础的知识嵌入到了脑子中，不然效果就不会很好。这就像你学习高级象棋策略，但是之前你连象棋的基本规则都没有弄清楚，显然在你不可能成功。</p>

<p>使用回忆、记忆关键点，而不是不过心的读书。这样做会让你更加专注也更加有效。重读只在一种情况下有效，那就是隔一段时间才重读，这样就会形成一种有空间感的重复联系（The only time rereading text seems to be effective, is if you let time pass between the rereading, so that it becomes more of an exercise in spaced repetition. ）。</p>

<p>学习过程就像拼图一样（最好把这幅图想象成无界的），你的大脑瞬时记忆首先是有限的（如前面在记忆章节讲的那样），就像你的手同时只能拿少数的几个拼块。当你把几个拼块通过不断的尝试后形成了一个小幅局部图，那么这局部幅图又变成了一个块，只不过稍微大一些。然后继续拼其他的块，然后散落的块越来越少，而局部块缺越来越大，直到最后把几幅局部图拼接起来就是一幅大图景。</p>

<p>现在你明白为什么记忆知识片段，同时建立知识片段之间的联系是学习知识和解决问题的关键所在。但是假如你只是看过某个知识，然后告诉自己：“Oh yeah，我会了！”。但是这个知识还并有真正变成你的。你几乎没有做任何事情让这些知识嵌入你的大脑中。仅仅是瞥一眼后就认为自己就能把知识学到就是最大的“学习完成幻想（Illusions of Competence）”。你必须让这些信息在脑中待一段时间并且做足够的联系和创造性思考延伸。<strong>还有就是注意要谨慎的使用高亮和划线（绝对的恶习）</strong>。如果满篇都是高亮或者划线，其实就是等于没有任何作用，除了使得书本更脏了外。此次之外过度的圈一些重点会让你愚弄你自己，让自己暗示相信自己圈的重点知识已经记在脑子中了，但其实不是。所以请在划重点前先仔细分析下真正的重点，并且尽量减少划线文字的面积。<strong>有一个更好的方法就是使用在旁边写下自己的疑问和理解笔记，比单纯的划线要好的多</strong>。</p>

<p>Jeff Karpicke还研究发现其他相关的领域 —— 学习假象。 有些学生总是不断的重读他们的笔记或者课本，是因为当他们手边就放着书或者开着google（百度），就会想当然的认为自己已经把这些知识装到脑子里面了，但是其实不是，因为太容易查看课本或者网络而放弃坚持努力使用recall（回忆，具体方法上面有说明），这样会导致一些知识只有在有课本和网络帮助下才会的知识，但是脱离这些手头可取的材料后并没有真正的学习到这些。</p>

<p>这就提醒我们，如果我们只采用照搬课本，花大量的时间不断机械重复，并不能实际把知识学习到。而一个很有用的来鉴别你是自己骗自己已经学会了，还是真正的学会的方法就是<strong>做练习</strong>， 测试你的学习成果。</p>

<p>在某种意义上来说，recall（回顾）也是一个种测试。让你明白你是否真正的掌握知识。当你在练习中出现了错误，这其实是一个非常好的事情。你不想重复你的错误，但是在大考试之前在小测试中犯错是非常有价值的。因为这些错误可以帮你了解自己在哪些方面做得不对，理解有偏差，并且做及时的纠正，从而学习的更好。</p>

<p>现在你已经意识到了回顾是一件非常强大的工具。但是还有另外一个技巧，那就是做回顾练习的时候尽量挑选和你平时学习不同的地方，这样会更加加深你的学习成果。你也许没有意识到，但是你在学习新的知识的时候，你会建立知识和周围环境微妙的联系。也许在你熟悉的环境中你能回忆起来的知识更多，但是当你考试的时候，往往是在另一个环境中，而这个环境你并不是熟悉，从而影响你的发挥。所以做回顾练习时候保持场地的多样性，会让让知识和环境脱节，不会发生联系，从而可以轻松在各种场合调用知识。</p>

<h2>过度学习、发生溺水、Einstellung 和 Interleaving（混洗）</h2>

<p>这章又要讲一大推概念了！不过这些概念都有巨大指导意义。有的是指出学习中遇到的问题，有的是指导怎么正确学习。</p>

<h2>过度学习（Over learning）</h2>

<p>什么叫过度学习？<strong>这种其实是指的当你不断的重复学习你已经掌握的知识</strong>。是不是很奇怪，有人会对已经掌握的知识还花功夫学习吗？还真有，比如当一个工人学习会了怎么操作机器，日复一日的重复，到后期基本上闭着眼睛都可以做到了。这种“过度学习”也许在某些情况下是好事，毕竟我们都希望“不动大脑的工作”。但是过度学习有它致命的缺点，第一很明显就是浪费时间，第二是当我们特别熟悉某些知识后，会把这种知识作为一个条件反射的方式来呈现，比如背诵圆周率一样，这样就没有办法进入一个种深入思考的模式。当这种知识是易变的情况下，再使用这种方式就会变成生搬硬套，比如千变万化的数学题。想想那些在考前背题的我们。</p>

<p>事实表明，一旦你一次性学习完了基础知识，继续再过度地重复这些知识并不会加强你想要连接的长期记忆。更糟糕的是只是聚焦于机械式的学习只会锻炼简单的技术性知识。经过一段时间后，你以为你使用这些“知识”解决一切问题了，但事实上你没有能力应用大部分东西。一般来说复习是一件很有意义的事情，这样可以加深神经元的强度和深度。但是如果你只复习你已经掌握的很好的知识，这样同样会让你产生知识习得假象，让你认为你掌握了所有知识，但是其实你是掌握的那部分相对于你来说比较容易的部分。所以你要改变策略，你要把更多的权重倾向于对于你来说比较难的那部分。这种策略就叫<strong>刻意学习</strong>。而这也是区分好学生和优秀学生的一个根本性策略。</p>

<p>上述的一切都与一个概念相关——<strong>定势思维（Einstellung）</strong>。</p>

<p>在这种现象中，你首先在脑海中直接浮现一种想法，而恰恰是这个你牢记熟悉的想法或者思考模式阻碍了你需求其他更好的方案。这就是思维定势的致命缺点。</p>

<p>密集式的（即在短时间内大量重复学习的内容）使用专注式学习模式，并且你以前习得的思维模式也会导致你建立一系列固定模式。而这些正式阻碍你到达真正有效的地方。碰巧的是，在德语中思维定势意味着观念模式（mindset）。基本上你可以把思维定势理解为一个路障，因为当你在首次寻找某些东西时候的情况很相似。由于有时候你对正在发生的事情或者你必须要做的事情的初始感觉很多时候是错误，这种错误的理解很容易发生在体育和科学学习中，更不用提其他学科了。所以在你学习新知识的时候就需要先清楚掉这些错误的旧思想和方法。</p>

<p>学生在学习中经常犯的错误是在学会游泳之前就直接跳入水中。换句话说就是他们盲目的开始做家庭作业，而之前没有看课本、出席课堂、浏览在线课程或者和熟悉此方面的人讨论。这种方法只会让你沉下去。学会一个新东西，并不只是学会这个范围的东西，还要和其他的不同的知识进行交互。最好的学习方法就是不断的在需要不同技巧和策略的问题和解决方案之间转换。这就叫做交替学习（interleaving）。</p>

<p>一旦你对学习技术有了一个基础的印象，就想在辅助轮的帮助下学骑自行车，就要开始在不同的问题、方法、概念和过程中交替练习。说起来这个概念有点困难。一个书中给定的章节，比如，一般是为了介绍特定的技术的，所以当你开始这个章节的学习时候，你就知道这个章节会用到什么技巧你将要用到。（补充一个场景就是，一般我们做数据课本某一章节的习题的时候，比如余弦定理，我们就知道这些练习题肯定是用了余弦公式。但是当把这些习题放到总和期末考试，我们未必能立即想起使用余弦定理。）所以还是尽量把学过的都混起来。或者你刻意的让自己是不是问问自己为什么使用这种技巧哦解决一些问题而不用其他的。你想让你的大脑习惯这种思想，仅仅知道怎么使用刚学习的概念、方法或者问题解决方案是不够的。你还要知道什么时候用。要贯彻交替学习的思想，比如通过在不同章节中切换问题，肯能阅读貌似让你学习更困难的了一点，但是实际上，这样会帮助学习的更深入。交替学习室非常重要的。尽管联系和重复对于建立坚实的神经模式是非常重要的，而交替的方法开启了灵活性和创造性的空间。这是让你离开练习和重复的地方，并且开始思考的更深入。当你交替的学习一个科目或者学科的时候你就开始使用哪个学科的知识开发你的创造能力。当你开始在不同学科之间交替学习时候，你可以更容易的建立不同领域知识块之间有趣的新连接，而这些连接可以进一步提升你的创造力甚至。当然，在艰深的领域建立牢固的知识块需要时间，所以有时候这里有所权衡。成为几个领域的专家意味着你可以从一个领域到另一个领域带来非常新的思想，但是这样也可能你擅长一个领域或者多个没有和那些仅仅专注于一个领域的人有深度。另一方面，如果你仅仅只专注于一个领域，你业务了解的非常深入但是你可能会进一步深陷于你熟悉的思考方式，而不可能去掌握新的思想。</p>

<p>科学哲学家Thomas Kuhn发现科学届中的大多数的重大成就不是年轻人就是那些原本接受的是另一个领域的人带来的。这些人不会轻易地陷入思维定式，因为先前的训练而把思想禁锢住。</p>

<p>最后，不要误认为学习仅仅只是从教师或者课本上获得。当你在叫一个小孩怎么有效的处理欺凌，或者你修复了一个漏水的水龙头，又或者你快速的打包好了去香港商务旅行的行李，所有这些说明了不同方面的学习的结果（the outcomes of important aspects of learning，学习的重要方面的结果or重要方面学习结果）。物理学家费曼在他的工作中，通过观察别人在餐厅里扔一个碟子而受到启发，而这项工作的成果让他获得诺贝尔奖。电视台节目“干尽苦差事”和“得有人做”的Mike Rowe展现了在大量的不同非学术领域的学习是多么的重要和有趣。</p>

<h1>第三章：</h1>

<h2>如何克服拖延症？</h2>

<h3>使用过程导向而不是结果导向</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>关键动作： 过程导向而不是结果导向（也许非常大跌平常人的眼镜）。来说明为什么这么做，我们来举一个例子，加入我们要完成一次家庭作业，当你一想要有个“任务”要完成心里就开始抗拒去做这件事情。但是如果你规定每天学习20分钟，当形成了习惯，就可以克服这种负面情绪。</span></code></pre></td></tr></table></div></figure>


<p>一种最好的提高学习效率的方式是使用心理工具和技巧去启发和推动你自己。首先通常在学习时，你应该意识到一段学习过程的开始总是带有一点点负面情绪的，即便当学习的科目是你喜欢的也会这样。所以现在的问题是你怎么控制这些情绪是很关键的？研究人员发现不拖延的人会把负面想法放在一边。停止浪费时间并且立即开始做事情。一旦你开始，你就会对学习感觉好一些。如果你发现你在回避特定的任务，原因是这些任务让你感觉不舒服，你应该知道还有另一种辅助的方法可以重新组织任务——这就是把学习集中在过程上而不是成果上。过程指时间流和这段时间里的习惯和动作。比如，我花费20分钟工作。结果是指产生，比如一次你需要完成的家庭作业。</p>

<h3>如何克服拖延症</h3>

<p>在这里，我们将具体的探讨下利用习惯的神奇力量来用最小的意志力来克服帮助你克服拖延症。你并不想对久习惯进行彻底的变革。你仅仅只想改变其中的一部分并且发展出另一个习惯。改变一个习惯的技巧是观察你对信号的反应。需要使用意志力的唯一地方是怎么改变你对信号的反应。要理解这个概念，我们需要回顾习惯并从拖延症的角度来重新分析这些要素。</p>

<p>第一要素就是信号。识别出示什么让你进入僵尸状的拖延症模式中。信号一般指下列4中类型中的一种：地点、时间、你的感受和反应。也可以是你对他人或者什么事情发生了。你是否有过本来在网上查询资料然后就发现你已经开始在网上瞎逛起来？是否一条短信打扰了你学习，然后即便你试图让自己保持在学习状态上也要花了10分钟才能返回到正经事上来？</p>

<p>拖延的最大问题是你常常意识不到自己已经开始拖延，因为拖延症是一种自发的习惯。你可以阻止大部分的破坏信号，通过关掉手机或者保持自己远离因特网并且其他让你占用碎片时间的分心事情。就想你正在做番茄计时法那样。</p>

<p>第二要素是常规。让我指出你经常转移自己的注意力到一些痛苦较小的事情上来避开学习。你的大脑想要自动的进行这样的惯性当你得到你的信号。（So this, is the reaction clue where you must？）所以这就是反应的线索，你必须主动重写你的旧习惯。重写动作的关键点就是需要一个计划。发展一种新仪式是非常有帮助的。一些学生形成了一个习惯就是当他们上课时候把手机留在车里，这样移除一个潜在的干扰源。许多学生发现了待在图书馆或者离家近的一个安静角落的价值，在合适的时间并断开所有互联网简单坐在一把心爱的椅子带来的高产效率。你的计划也许一开始并不顺利，但是仅仅保持继续。在有必要的时候调整计划，品尝胜利的滋味当你计划有效时候。不要试图一下子改变所以事情。番茄技术法可以极大的帮助你移除掉对信号的反应。</p>

<p>第三要素是奖励。有时候这会要一点投资。为什么你在拖延？你可以替换情感失落吗？也许用完成某事后的骄傲感觉，甚至是非常小的事情，比如仅仅一种满足感。你可以赢得内心的打赌或者比赛吗？让你玩游戏，或者允许你自己放纵的喝一杯拿铁，或者浏览喜爱的网站，或者给自己提供一个不费脑的电视节目或者上网时候没有负罪感。记住这些习惯是强大的，因为它们可以创造神经系统的欲望。加上一个新的奖励可以帮助你想克服你之前的欲望。一旦你的大脑开始期待新的欲望，旧习惯可以被重写，允许你创造新的习惯。</p>

<p>许多人发现奖励需要在一个特点的时间点。例如，和一个朋友在快餐店共进午餐或者在下午5点前停止主要的工作。设置一个固定的，小的截止时间点有助于激励工作。如果一开始你发现进入工作状态有困难，不要感觉难过。我又是发现要进入状态需要几天的单调无聊，通过几轮番茄计时法技术，流畅的状态才逐渐展开并且发现自己开始享受了开始一项新的工作。也要记住你完成某事越有效果，就会带来越多的享受感。</p>

<p>第四要素是信念。改变你拖延习惯最关键的点就是相信你可以做到这件事。你也许发现当过程变得非常有压力时候，你渴望退回到舒服的旧习惯中。信心你的新系统是有效的可以让你渡过这个难关。发展一个新圈子可以帮助信念打下基础。和同学一起活动，或者联系网络课程的同学，这些同学也许你也想发展的可行思想。发展并且鼓励志同道合（culture with like-minded）的朋友可以帮助我们在我们意志薄弱的时候，想起信念的价值。</p>

<h3>评判人生和学习</h3>

<p>学习对于大多数人来说涉及到许多任务微妙的平衡。让你对你尝试学习和完成保持展望的一种好的方法是一周在计划本写一次简短的关键任务列表。每一天另起计划本的一页，写下你能合理承受或完成的任务列表。尝试在前一天晚上写下每天的任务列表。为什么前一天晚上呢？研究者表明这样可以帮助你潜意识里抓住列表上的任务，这样你可以相处怎么完成它们。在你要睡觉之前写下列表，召集你的僵尸，让他们帮助你完成下一天列表的项目。如果你没有写下任务到列表中，僵尸们潜伏在工作记忆的4个槽位的边缘上，浪费宝贵的大脑资产。但是一旦你写下了任务列表，这就释放工作记忆用来解决问题。所以大家来看我的日常任务列表。正如你所见，这里只有6个项目。有些是过程导向的。比如，我有一篇论文要在几个月内发在一份期刊上。所以，我在几天中每天花了一些番茄时间去完成它。一些项目是结果导向的。但是那是因为它们是在短时间内可完成的。</p>

<p>看下我的提醒内容。我想当我在进行项目时保持注意力到每个中，同时我想要乐在其中。但是我确因为忘记关掉邮件而被其他事情而分心。为了让我自己重回正规（To get myself back into gear），我使用点乃哦上的时钟设置了一个22分钟的番茄挑战。我不必每次都一样。并且注意要转移到番茄模式，我首先需要切换到过程导向。在我的列表中没有一个大项目，因为我一天中很多有其他的事情。需要参加的会议，需要教授的课程。有时候我会分散一些涉及身体锻炼到我的列表中，甚至只是清理东西而已。当然我承认，这不是我最喜欢做的事情。不过因为使用这些小事作为思维发现的休息时间，我经常还是很期待去做这些事情。在学习中结合其他任务似乎可以是所有事情更有趣并且可以避免你不健康的久坐。随着时间增长（over time），经验增长，我对给定的任务需要花多久的时间能越来越好的估计了。</p>

<p>你会发现你自己提神给的很快，因为你能更加准确地把握在一定时间内你可以合理完成的什么工作。在你的计划本上标记上做了什么和没有做什么。关注你每天的目标的完成时间是下午5点。这看起来有点不对劲，不是吗？但是这是合理的，并且这是每天日程计划本里最重要的部分。计划你休息的时间和计划你工作时间同样重要。一般，我想在下午5点的时候下班，虽然当我在学习一些新知识的时候，在晚上稍作休息之后，睡觉之前复习一遍是很不错的。有时需要完成大项目要时，比如，这个MOOC课程，偶尔需要加下班。你也许会想，这不可能的，我们知道你是一位教授，已经度过青春校园时光。早点下班对来来说没什么。但是，一位我最尊敬的学者，Cal Newport，在他的整个学习生涯中5点开始休息。他最终获得了MIT的博士学位。换句话说，看起来貌似是难以置信的，但是这个方法对于有着严苛的学习任务的本科或者研究生也是有效的。随着时间，这些努力学习之余还坚持保持健康娱乐的人会胜过这些一味追求勤勉的人。</p>

<p>当然，你的生活也许不会自己在时间表上安排出间歇和休息时间。你也许对两份工作或者太多的课程而逼得筋疲力尽。但是不管怎样生活还是要继续，尝试着挤出些时间来休息。</p>

<p>还有一件事，（As writing xxx recommends to。。其中的as怎么翻译？引导什么关系？）正如写作教练Daphne Graygrant对她的学院建议的，在早晨吃你自己的青蛙。先开始一项最重要也最不喜欢的任务。在你一起床之后至少进行一个番茄时间。这种方法是难以置信的有效的。你是否需要因不可预见的事件而改变某些计划？当然，但是记住幸运定律。幸运女生偏向于热与努力的人。良好的计划是努力中的一部分。保证你的注意力在你的学习目标上，并且尝试不要被偶然的绊脚石而变得太过于不确定。</p>

<h3>章节总结</h3>

<p>良好的学习一般都是每天一点点的建立坚实的神经结构的。就想通过哑铃天天运动来建立肌肉一样。这就是为什么克服拖延症如此的重要。你想要保持你的学习并且避免最后的临时抱佛脚。这里是有一个克服拖延症的关键点总结。
1. 坚持制定一个计划，这样你就可以很容易的的发现什么时候你实现了目标，或者观察你做到什么而没做到什么。
2. 保证你自己有规律的日常习惯和任务。
3. 在晚上之前写下你的计划任务，这样你的大脑可以有时间处理你的目标，并且保证其能实现成功。
4. 分解你的工作成一些列的小任务。
4. 确保你的和你的僵尸们得到奖励。
5. 花几分钟的时间来品尝快乐和胜利的感觉，这些感觉可以给你的大脑概念概念临时模式的一个机会。
6. 推后奖励直到你结束了你的任务。
8. 观察你的拖延信号。尝试保证你自己在一个少拖延暗示的环境中，例如安静的图书馆角落。
9. 对你的新系统产生信赖。你想要在注意力集中的时间里努力工作。并且也要足够信赖你的新系统，这样当你规定的休息时间到的时候，你可以无罪恶感的放松。
10. 如果你任然拖延就指定备用计划，没有人是完美的。
11. 每天首先吃自己的青蛙，从最重要和最喜欢的事情开始每一天。</p>

<p>快乐的实践吧！</p>

<p>翻译后记：
1. 发现作者的语言表述真的很啰嗦，慢慢的发现冗长是大错，这也是我写东西的大忌。
2. 语言需要逻辑分析，不然很容易陷入错误部分拆解和分析中。
3. 英语和中文的思维果然不一样，有些句子真的是理解但是找不出合适形式表达出来。
4. 自己的中文不好。。。。超受打击。。。
5. 发现有很多句子我根本没有理解清楚其意思，甚至是理解错误的。或者表面上是理解了，但是让我自己表达出来，我才发现我根本没有理解！！！悲剧，无效学习的典型呀！</p>

<p>短语：
the evening before是前一天晚上，而befor the evening是晚上之前。。。。
realistic 切实可行的
I aim to be physicist!!</p>

<h2>资料列表</h2>

<ul>
<li>番茄图解法</li>
<li>拖延症（procrastination）</li>
<li>意志力（willpower）</li>
<li>习惯的力量（the power of habits）</li>
</ul>


<p>Interleaving your studies, making it a point to review for a test</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Data File Organization]]></title>
    <link href="http://woodcarver.github.io/blog/2016/09/04/data-file-organization/"/>
    <updated>2016-09-04T17:01:19+08:00</updated>
    <id>http://woodcarver.github.io/blog/2016/09/04/data-file-organization</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduce Hive]]></title>
    <link href="http://woodcarver.github.io/blog/2016/08/31/introduce-hive/"/>
    <updated>2016-08-31T22:57:57+08:00</updated>
    <id>http://woodcarver.github.io/blog/2016/08/31/introduce-hive</id>
    <content type="html"><![CDATA[<h1>Rcfile的设计</h1>

<ul>
<li>key/value</li>
<li>column-store and row-store , why?
row-store: fast loading data in real-time in HDFS, because data coming by row and will be stored in one place event in one block. But it can not support fast ad-hoc query.</li>
</ul>


<p>怎么衡量一个文件组织方式？答案只有一个，那就是它满不满足使用性能？
好的，对于一个文件我们要做的事情无非就是：读，写。
读有又，位置和数据大小的特性。比如按位置划分就有随机读，顺序读，逆序读等等，大小就是读一条数据，一片数据。再把位置和大小一结合，呵呵！是不是很复杂？
对于hive来说，其读特性就是：读一行也行，读一列也快，还有更牛的是还能建立索引。</p>

<p>写的话，也有位置和大小之分。随机写，在头位置写，在未位置写。大小写入一条数据，写入一片数据。再一结合。。。。</p>

<p>hive写的就是追加，这也是为什么要先水平在垂直，要的就是加载数据速度，还有实时加载数据的特性。因为打开一个节点的比打开无数节点靠谱很多不是吗？还往单机上说，就是打开一个文件总比打开多个文件写要快不是吗？
同时如果写操作是流式的，那么每次写入其实都需要重新组织数组块，进行压缩。</p>

<p>如果把读和写结合起来就产生了更邪恶的操作，那就是删除和更新。</p>

<h1>HSQL怎么解析到MapReduce？</h1>

<h2>怎么使用MapReduce实现Join？</h2>

<h2>怎么使用MapReduce实现Group By？</h2>

<h2>怎么使用MapReduce实现Distinct？</h2>

<h1>如何在Hive中加载一个外部的脚本文件？</h1>

<h1>写UDF, UDAF, UDTF</h1>

<p>Hive提供UDF, UDAF, UDTF三种接口来给用户扩展sql的功能。当然为什么要有三个接口呢？他们有什么区别？这个我们下面会依次讲到。</p>

<p>首先我们需要知道现在都有哪些实现好的函数，就不用再造轮子了是吧！</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; show functions;
</span><span class='line'>!  
</span><span class='line'>!=  
</span><span class='line'>......
</span><span class='line'>
</span><span class='line'>&gt; describe function max;</span></code></pre></td></tr></table></div></figure>


<p>show functions这个命令可以列出现有的函数，而describe function function-name会列出具体的函数描述。</p>

<p>写自己的函数前，我们先要明确下我们的函数到底会怎么被Hive运行？会在那个阶段运行？这个就不得不说SQL语句的解析了。一般SQL的解析顺序是：</p>

<ul>
<li>from</li>
<li>on</li>
<li>join</li>
<li>where</li>
<li>group by</li>
<li>having</li>
<li>select</li>
<li>distinct</li>
<li>union</li>
<li>order by</li>
<li>limit</li>
</ul>


<p>本质上SQL是一个种集合代数运算操作的语言，每一种操作都是一种代数操作。
这个顺序基本可以这么理解：首先需要确定数据源（from后面的表），然后数据确定范围（where条件筛选），然后对这个数据进行分组（group），然后选择要展示的列（select），然后可以对选择的数据集进行排序（order by）。后面如果还有一个数据集那么可以union。其中还有像having，distinct和limit操作的顺序我暂时还不能理解这里就不讲了，还有发现distinct的执行顺序和group by并不在一起让而且在select后面，也许这里就会产生一些写法上的注意点。其中这个排序也可能在不同的数据库引擎中执行顺序不一样。
具体详情参看<a href="http://blog.jobbole.com/55086/">这篇文章</a>。</p>

<p>那么hive的函数要做到在SQL语句哪个部分都能运行，所以对函数的语义一定要弄清楚。而且一定要把函数处理过程想想成流式的，因为在SQL中所有的操作都是流式操作。</p>

<ol>
<li>UDF只能实现一进一出的操作, 即UDF只能操作一行的数据，而要操作多行的数据需要使用UDAF实现</li>
<li>实现聚合函数请用UDAF， 解决进多出一</li>
<li>UDTF(User-Defined Table-Generating Functions) 用来解决 输入一行输出多行(On-to-many maping) 的需求</li>
</ol>


<h2>怎么解决hive中的数据倾斜问题</h2>

<h2>hive sql优化</h2>

<ul>
<li>裁剪列，不要写不查的列</li>
<li>裁剪分区，如果是子查询限制条件一般放在子查询内部</li>
<li>Join1 —— 小表前置，想想hash join的过程</li>
<li>Join2 ——</li>
</ul>


<h2>推荐书目</h2>

<ul>
<li><a href="https://www.amazon.cn/Hadoop%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E6%80%80%E7%89%B9/dp/B016OFNZYM/ref=sr_1_2?ie=UTF8&amp;qid=1477288333&amp;sr=8-2&amp;keywords=hadoop%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97">Hadoop权威指南</a></li>
</ul>


<p>Hadoop的基础书籍，基本上可以说是必读书。书中详细的介绍了hadoop的发展历史，设计思想、任务调度框架、计算框架编程、测试等。是进入hadoop世界的一本非常好的材料。而且作者本身就是hadoop的以为重要代码贡献者。</p>

<ul>
<li><a href="https://www.amazon.cn/MapReduce%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%88%E7%BA%B3/dp/B00NA989GU/ref=sr_1_1?ie=UTF8&amp;qid=1477288440&amp;sr=8-1&amp;keywords=mapreduce%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">MapReduce设计模式</a></li>
</ul>


<p>当你有了mapreduce的基础知识后，再看这本书，就会非常容易理解Hive中的HQL是怎么转化成map reduce任务了。最重要的是当你理解了转化的过程和最终的map reduce任务，就可以着手优化HQL语句，解决数据倾斜、冗余查询操作等问题。涉及的内容非常实用，给出的示例可执行度很强。对于编写mapreduce程序也有巨大提升。</p>

<ul>
<li><a href="http://www.cnblogs.com/yurunmiao/p/4745951.html">Hadoop RCFile存储格式详解（源码分析、代码示例）</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Design Pattern]]></title>
    <link href="http://woodcarver.github.io/blog/2016/08/22/design-pattern/"/>
    <updated>2016-08-22T23:00:57+08:00</updated>
    <id>http://woodcarver.github.io/blog/2016/08/22/design-pattern</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Manipulate Binary Stream]]></title>
    <link href="http://woodcarver.github.io/blog/2016/08/14/how-to-manipulate-binary-stream/"/>
    <updated>2016-08-14T20:47:13+08:00</updated>
    <id>http://woodcarver.github.io/blog/2016/08/14/how-to-manipulate-binary-stream</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Use Jmock]]></title>
    <link href="http://woodcarver.github.io/blog/2016/08/14/how-to-use-jmock/"/>
    <updated>2016-08-14T14:35:32+08:00</updated>
    <id>http://woodcarver.github.io/blog/2016/08/14/how-to-use-jmock</id>
    <content type="html"><![CDATA[<p><a href="http://www.jmock.org/expectations.html">jmock官网</a></p>

<h1>测试框架</h1>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void testSomeAction() {
</span><span class='line'>    ... set up ...
</span><span class='line'>
</span><span class='line'>    context.checking(new Expectations()
</span><span class='line'>        ... expectations go here ...
</span><span class='line'>    );
</span><span class='line'>
</span><span class='line'>    ... code being tested ...
</span><span class='line'>
</span><span class='line'>    context.assertIsSatisfied();
</span><span class='line'>
</span><span class='line'>    ... other assertions ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>其中最重要的一个步骤就是context.checking。这个方法中定义的expectation就是需要关注的。也就是你要模拟的方法的输入和输出。
其他格式是这样的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>invocation-count (mock-object).method(argument-constraints);
</span><span class='line'>    inSequence(sequence-name);
</span><span class='line'>    when(state-machine.is(state-name));
</span><span class='line'>    will(action);
</span><span class='line'>    then(state-machine.is(new-state-name));</span></code></pre></td></tr></table></div></figure>


<p>其每个短语的具体意思如下：</p>

<table>
<thead>
<tr>
<th>one    </th>
<th>The invocation is expected once and once only.</th>
</tr>
</thead>
<tbody>
<tr>
<td>exactly(n).of</td>
<td> The invocation is expected exactly n times. Note: one is a convenient shorthand for exactly(1).</td>
</tr>
<tr>
<td>atLeast(n).of </td>
<td>The invocation is expected at least n times.</td>
</tr>
<tr>
<td>atMost(n).of   </td>
<td>The invocation is expected at most n times.</td>
</tr>
<tr>
<td>between(min, max).of   </td>
<td>The invocation is expected at least min times and at most max times.</td>
</tr>
<tr>
<td>allowing   </td>
<td>The invocation is allowed any number of times but does not have to happen.</td>
</tr>
<tr>
<td>ignoring   </td>
<td>The same as allowing. Allowing or ignoring should be chosen to make the test code clearly express intent.</td>
</tr>
<tr>
<td>never  </td>
<td>The invocation is not expected at all. This is used to make tests more explicit and so easier to understand.</td>
</tr>
</tbody>
</table>


<p>所有的函数都是可以选的，例如你可以如下组合你的exception。</p>

<h1>例子</h1>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void testReturnsCachedObjectWithinTimeout() {
</span><span class='line'>    context.checking(new Expectations()
</span><span class='line'>        oneOf (clock).time(); will(returnValue(loadTime));
</span><span class='line'>        oneOf (clock).time(); will(returnValue(fetchTime));
</span><span class='line'>
</span><span class='line'>        allowing (reloadPolicy).shouldReload(loadTime, fetchTime); will(returnValue(false));
</span><span class='line'>
</span><span class='line'>        oneOf (loader).load(KEY); will(returnValue(VALUE));
</span><span class='line'>    );
</span><span class='line'>
</span><span class='line'>    Object actualValueFromFirstLookup = cache.lookup(KEY);
</span><span class='line'>    Object actualValueFromSecondLookup = cache.lookup(KEY);
</span><span class='line'>
</span><span class='line'>    context.assertIsSatisfied();
</span><span class='line'>    assertSame("should be loaded object", VALUE, actualValueFromFirstLookup);
</span><span class='line'>    assertSame("should be cached object", VALUE, actualValueFromSecondLookup);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduce CAP]]></title>
    <link href="http://woodcarver.github.io/blog/2016/07/29/introduce-cap/"/>
    <updated>2016-07-29T10:04:53+08:00</updated>
    <id>http://woodcarver.github.io/blog/2016/07/29/introduce-cap</id>
    <content type="html"><![CDATA[<p>这篇博文主要是对<a href="http://www.infoq.com/cn/articles/cap-twelve-years-later-how-the-rules-have-changed/">《CAP理论十二年回顾："规则"变了》</a>的读后感。</p>

<h1>CAP到底讲什么，为什么不能同时满足？</h1>

<p>首先明确一点，CAP是一个分布式系统的特性，如果你没有多个服务节点，就不可能发生分区。先解释下概念：
- C —— 执行的结果能同时反映到所有节点上。等同于所有节点访问同一份最新的数据副本。也许这里需要很多的具体不变性约束，比如主键不能重复。
- A —— 这个是指访问的节点是正常的，那么就能正常执行请求（所以和P的一个冲突点就是当系统部分失效，这个系统到底是判定为失效还是正常？）
- P —— 这个特性是说当系统的节点之间通信出现了问题，导致之间不能同步，然后还能继续提供服务。
其实我第一次读这个概念，就是不明白为啥这三个方面不能全部同时获得。然后看了个这个例子：</p>

<blockquote><p>理解CAP理论的最简单方式是想象两个节点分处分区两侧。允许至少一个节点更新状态会导致数据不一致，即丧失了C性质。如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了A性质。除非两个节点可以互相通信，才能既保证C又保证A，这又会导致丧失P性质。一般来说跨区域的系统，设计师无法舍弃P性质，那么就只能在数据一致性和可用性上做一个艰难选择。不确切地说，NoSQL运动的主题其实是创造各种可用性优先、数据一致性其次的方案；而传统数据库坚守ACID特性（原子性、一致性、隔离性、持久性），做的是相反的事情。下文“ACID、BASE、CAP”小节详细说明了它们的差异。</p></blockquote>

<p>上面的例子说的太清楚了，当分布式系统发生了节点之间通信失败，就相当于一个整体的服务发生断裂，分成了几个服务块。从而丢失了其对等性（即从任意一个节点都可以访问到整个系统）。然后这个时候如果其中一部分提供服务，比如写操作通过一节点写入了，但是因为不能通信没有办法复制到其他节点，导致了系统的不一致性。这样就就丢失了C，但是还好保住了A。
接着如果要追求C，那么只有等节点之间的通信成功才行，那么就需要写入操作延迟或者这个期间拒绝服务。那么都不能服务了，自然就没有了A。</p>

<p>所以来说当没有发生分区的时候，C和A可以完美保持。但是发生了分区，那么要容错，C和A可能就不能同时保持。
其实这不是一个3选2的问题，因为你没办法选择系统不分区，当通信出问题这个是能选择的吗？这个是故障，你有办法选择故障？所以其实所有的分布式系统都是在C和A之间进行设计权责。</p>

<h1>C和A之间选择不是0和1的选择，而是一种连续式选择</h1>

<p>从上面的例子看，好像选择C就必须放弃A，反之亦然。但是其实所有这些都有中间方案。C和A的定义也有各种灰度定义。
比如C的定义，最严格的定义就是一个分布式事务结束后，所有的副本在任何时刻都是一致的。但是这个定义可以放宽。时间不在是同时，而是一段时间，给一个时间窗口。或者一阶段内可以不一致，但最终变成一致的。比如上面的例子中，在发生分区的时候，可以暂时不一致，等到通信问题解决了，开始恢复一致性。</p>

<p>而对于A的定义来说，也是有各种层次，在发生分区的时候，可以选择限制部分操作，同时提供一个些事后比较好恢复的操作。</p>

<h1>一种经典的系统设计模式</h1>

<p>因为在分布式系统中，基本是没有办法选择不要分区的，所以为了保证系统的可用性，和一致性的博弈，经典的设计模式就是分情况对待。当不发生分区的时候保证完美的CA，到出现了分区，进入分区模式，等待分区恢复后，恢复系统，最终达到一致性后，再次进入完美CA状态。</p>

<p><img src="../images/posts/CAP1.png" alt="" /></p>

<ul>
<li>检测到分区开始</li>
<li>明确进入分区模式，限制某些操作，并且</li>
<li>当通信恢复后启动分区恢复过程</li>
</ul>


<p>最后一步的目的是恢复一致性，以及补偿在系统分区期间程序产生的错误。</p>

<p>当系统进入到分区模式，它有两种可行的策略。其一是限制部分操作，因此会削弱可用性。其二是额外记录一些有利于后面分区恢复的操作信息。系统可通过持续尝试恢复通信来察觉分区何时结束。</p>

<h1>副本</h1>

<p>一谈到副本，最大的问题就是其一致性，这个问题不仅仅是在分布式系统中涉及，只不过分布式系统是鼓励副本的存在，而在这个基础上开始设计一套一套的解决方案。但相对其他领域——比如设计模式OOD，关系数据范式都是从另一个方向把<strong>重复（副本）扼杀在摇篮中</strong>，比如策略模型，把能公用的都抽象出来复用。</p>

<h1>可怕的一致性</h1>

<ol>
<li>一个场景，一个问题</li>
<li>如何解决这个问题？</li>
<li>这个解决方法是错的吗？</li>
<li>这个方法是对的吗？</li>
<li><p>有没有更优的解法？</p></li>
<li><p>隐喻，一个直观的例子</p></li>
<li>过度到实际的模型</li>
<li>证明模型</li>
<li>实际用途</li>
</ol>


<h1>reference</h1>

<ul>
<li><a href="https://martin.kleppmann.com/2015/05/11/please-stop-calling-databases-cp-or-ap.html">Please stop calling databases CP or AP</a></li>
<li><a href="https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed">CAP Twelve Years Later: How the &ldquo;Rules&rdquo; Have Changed
</a></li>
<li><a href="http://www.cnblogs.com/esingchan/p/3917718.html">分布式理论之一：Paxos算法的通俗理解</a></li>
<li><a href="http://www.cnblogs.com/endsock/p/3480093.html">Paxos算法细节详解(一)&ndash;通过现实世界描述算法</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何理解一个数据存储系统]]></title>
    <link href="http://woodcarver.github.io/blog/2016/07/24/how-to-understand-a-database/"/>
    <updated>2016-07-24T14:57:42+08:00</updated>
    <id>http://woodcarver.github.io/blog/2016/07/24/how-to-understand-a-database</id>
    <content type="html"><![CDATA[<h1>储存系统的目的</h1>

<p>其实储存系统的目的估计和文件系统没什么两样，就是存储数据并且取出数据。关键的两个操作还是 <strong>write/read</strong>。但是说差异巨大也是合理的，因为因为文件系统的是面向<strong>文件</strong>的，而对数据的结构和信息是隐藏起来，可以说毫不关心数据的特质，全部打包放在一起。而数据储存系统而转换了问题的角度，把主角换成了<strong>数据</strong>，提供数据的特定的组织方式，针对不同结果的组织给出方便的获取和写入方式。</p>

<p>说明其不同，让我们看一个例子。拿最常数的用户表说明，如果我们建立的一个网站，提供用户注册留言。
设想我们没有数据库，只能存储文件，那么我们就会这么存储：</p>

<blockquote><p>user.txt
|user_id | name | phone|
|&mdash;&mdash;&ndash;|&mdash;&mdash;|&mdash;&mdash;|
|001     |Alice |123333|
|002     |Bob   |166666|
|&hellip;     |&hellip;   |&hellip;   |</p>

<p>message.txt
|user_id | message|
|&mdash;&mdash;&ndash;|&mdash;&mdash;&ndash;|
|001     |I am Alice|
|002     |I am Bob|
|&hellip;     |&hellip;   |</p></blockquote>

<p>这时候一个用户查看自己发送过的所有的留言。首先做的是从uesr.txt中扫描，找出Alice的user_id信息，然后再在message.txt找出所有的留言。这个过程估计需要你不短的一段代码。跟别提还要各种分割字符串，切出各种字段。还有更难控制的字段的类型，比如日期格式等。</p>

<p>而上面的通用常见的问题，通过数据库系统得到了很好的解决。</p>

<h1>模型层次</h1>

<p>既然说了数据库的目的，那么就来看看怎么构建一个数据库。先看下面的图，描述了数据库的使用层次和实际实现层次。使用层次就是面向用户（程序员），说明系统张什么样子的。而实现层次就是为了支持使用层次而设计的实现方法。使用更专业的术语那就是逻辑层次一个是物理层次。</p>

<p><img src="http://woodcarver.oss-cn-shanghai.aliyuncs.com/post/data_system.png" alt="dddd" /></p>

<p>逻辑层次就是开发者看到的、理解的、认为的样子。对于这层来说大部分数据引擎其实都差不多，不是关系型的就是key-value型。当不了解引擎内部的物理实现逻辑的时候，用户肯定会按照自己理所当然的想法去使用这个系统。这个想法无可厚非，能做到让用户安全放心的使用，尽量屏蔽底层实现也是数据管理系统的追求。不过现在看来当你的数据大一点的时候这个想法有点不现实。</p>

<p>所以如果还不关注其内部实现，就会不断出现红框框的问题，知道你放弃这个系统为止。</p>

<p>但是如果你开始理解其物理层次的机制后，会对逻辑层次有更深入的理解，一些问题也能迎刃而解。</p>

<h1>当谈起一个数据库的时候，我们在说什么？</h1>

<p>两个方面，了解其逻辑模型和物理模型。既然逻辑模型都一样或者差不多，为什么还需要不同的物理模型？原因就没有哪种数据库能支持各种操作到极致的，每种数据库都各种操作都有取舍，各有优缺。有些支持快速的响应，例如redis，有些偏向于？？？？？。</p>

<h2>谈逻辑模型——提供什么服务，支持哪些操作</h2>

<p>两大数据模型 —— 关系型数据模型、key-value数据模型
都支持add、delete、select和update。不过具体支持的方向不同，而不同关键点在<strong>位置</strong>和<strong>范围</strong>的不同。</p>

<ul>
<li>关系型数据模型：基本模型是一个张二维表。

<ul>
<li>add：在表的尾部添加即可。</li>
<li>delete：查找到位置，然后删除。</li>
<li>select：全表扫描，或者利用索引技术。</li>
<li>update：查找到位置，然后更新。</li>
<li>没有递归结构，导致对嵌套数据储存不友好。需要大量的冗余数据。</li>
</ul>
</li>
<li>key-value数据模型

<ul>
<li>add：利用hash funciton后找到其位置，然后添加。</li>
<li>delete：查找到位置，然后删除。</li>
<li>select：利用hash定位。</li>
<li>update：查找到位置，然后更新。</li>
<li>天然的递归结构，对嵌套结构支持友好方便。</li>
</ul>
</li>
</ul>


<p>因为几乎所有的操作都和查找有关，其中查找的效率能直接决定系统的效率。关系型数据库的查找效率(一条数据)要么是O(n)要么是O(logn)，让然也可以是O(1)，以为可以有hash索引。而key-value的查找效率是O(1)。</p>

<h2>谈物理层次——怎么实现这些操作的？如何组合才能最大的发挥其性能？</h2>

<p>物理层次出了决定操作的性能外，还有一个重大的不同，就是对规模扩展的支持程度有巨大的差别。关系型数据库的一个诟病就是对规模扩展非常差。其优良的操作模型和结构化数据要求进一步对大数据量的日志型提出了挑战。</p>

<h2>一个表现的具体问题，<a href="http://stackoverflow.com/questions/1636379/why-db-indexes-use-balanced-trees-not-hashtables">Why DB indexes use balanced trees, not hashtables?</a></h2>

<h2>Has different Characteristics for data operatings</h2>

<p>B-Tree supports comparisons  =, >, >=, &lt;, &lt;=, BETWEEN operators and like, while HashTable only supports =.
so the using scope of HashTable is too narrow.</p>

<h2>HashTable is hard to rescale or grow</h2>

<p>The size of hashtable is determined when it is created. If you add more data than it&rsquo;s size, you need to resize it. And it&rsquo;s very ineffcient. althought there are rescale algorithm or other replication policy(like in redis).</p>

<h2>memory usage effiency</h2>

<p>B+ Tree can be load into memory partially, while HashTable can not. ?? really?</p>

<h2>refernece</h2>

<ol>
<li><a href="https://dev.mysql.com/doc/refman/5.5/en/index-btree-hash.html">Comparison of B-Tree and Hash Indexes</a></li>
</ol>


<h1>reference</h1>

<ul>
<li><a href="https://www.tutorialcup.com/dbms/data-independence.htm">Data Independence</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[java里为什么有了Thread还要设置一个Runnable？]]></title>
    <link href="http://woodcarver.github.io/blog/2016/07/20/why-need-runnable-while-we-already-have-thread-in-java/"/>
    <updated>2016-07-20T21:36:45+08:00</updated>
    <id>http://woodcarver.github.io/blog/2016/07/20/why-need-runnable-while-we-already-have-thread-in-java</id>
    <content type="html"><![CDATA[<p>我学习多线程疑惑，为什么会有这种代码出现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nf">Runnable</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>               <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;this is a runnable&quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">);</span>
</span><span class='line'>    <span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>不是有个更简便的方法吗？</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Thread</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;this is a thread&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">};</span>
</span><span class='line'><span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>虽然很容易知道Runnable是个接口，而Thread是Runnable的一个具体实现。但是既然concurrent包中只有Thread一个类实现，那些Runnable这个接口到底有什么用？
答案就是用户可能会使用到多类继承，但是这在java中是禁止，只能用interface实现。比如我想设计一个任务队列，然后这个任务可以随时开启一个线程运行。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">class</span> <span class="nc">TaskQueue</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">Runnable</span> <span class="o">{</span>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">//...</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据分析利器 —— 列式储存数据库]]></title>
    <link href="http://woodcarver.github.io/blog/2016/07/18/the-world-about-oriental-column-database/"/>
    <updated>2016-07-18T11:00:26+08:00</updated>
    <id>http://woodcarver.github.io/blog/2016/07/18/the-world-about-oriental-column-database</id>
    <content type="html"><![CDATA[<h1><a href="https://en.wikipedia.org/wiki/Column-oriented_database">列式数据库</a></h1>

<p>什么是列式数据库？可能大家也才到了，既然有列式数据库，那么肯定就有行式的喽！确实是这样的。也许大多数人并不了解数据库储存模型（storage model 即physical schema）和数据库的数据模型（data model 也叫 logical schema），不过对上层是使用者也没多大关系。不过我们现在讲的列式和行式就是指数据库的storage model，而他们支持同样的data schema，即对data model感知不到storage model的实现区别。
一个数据库的data model约定可以进行上层数据操作，而storage model决定这些操作的性能。比如，No Sql数据库使用的是data model都是key-value，而储存模型有map结构实现，也可以由tree结构实现。而对于sql数据库，其数据模型是一张二维表，而至于怎么存储这张二维表，很容易就可以想到可以按行存储和按列储存。按行存储就是我们现在常见操作型数据库，而是最大众的数据库，比如MySql、Oracle、……等等你所知道大部分数据库。而按列储存的数据库现在也是很有名，比如Hive、Vertica、Druid、Infobright等。</p>

<h1>为什么要行式数据库又要列式数据库？</h1>

<p>先让让我们想象关于二维表我们有哪些操作？—— select、update、delete和insert。这些操作都会需要找到相应的位置，所以这些操作的基础都是search。
而基本的算法都是即从时间考虑也是从空间考虑的。我们开始具体举个例子。</p>

<p>在数据库储存作为实际的一堆储存在磁盘上的文件，在设计不得不考虑磁盘的特性。一般的磁盘特性，其实所有的储存都有一个特性就是对于locality良好的存取性能是随机存取的好几倍。我们现在把一块想像成一组固定大小的块，如图： disk logic model 而文件的内容实际会被分开按照磁盘逻辑块来储存，数据库主要任务就是怎么组织这些逻辑块来取得更好的读取性能和便捷性。
<img src="../images/posts/disk_block.png" alt="" /></p>

<p>在不考虑索引的情况下，所有的磁盘读取都是顺序读取，这意味了要查找一个东西，都需要扫描全表或者部分表。很直观的道理，读取的性能就是取决于扫描的范围。范围越大，速度当然越慢。
我们先假设我们有一堆如下的数据：</p>

<table>
<thead>
<tr>
<th>RowId</th>
<th>EmpId  </th>
<th>Lastname  </th>
<th>Firstname</th>
<th> Salary</th>
</tr>
</thead>
<tbody>
<tr>
<td>001  </td>
<td>10    </td>
<td>Smith     </td>
<td>Joe     </td>
<td>40000</td>
</tr>
<tr>
<td>002  </td>
<td>12    </td>
<td>Jones     </td>
<td>Mary    </td>
<td>50000</td>
</tr>
<tr>
<td>003  </td>
<td>11    </td>
<td>Johnson   </td>
<td>Cathy   </td>
<td>44000</td>
</tr>
<tr>
<td>004  </td>
<td>22    </td>
<td>Jones     </td>
<td>Bob     </td>
<td>55000</td>
</tr>
</tbody>
</table>


<h2>行式储存模型</h2>

<p>好现在我们开始让磁盘里塞，假设我们的磁盘块只能容下5个字段（抽象的，假设我们的这些字段的大小都一样），因为我们是按找行优先的，所以结果就如下：
<img src="../images/posts/row_oriented.png" alt="row oriented model" /></p>

<p>于是当我们要找Jones的所有信息的工资时候，我们会依次从第一块磁盘块直到扫描到最后（为什么要扫到最后，因为是在找全部叫Jones的信息，所以不扫都最后都不能确定是否会遗漏）。一共需要扫4块，然后取出其第二块和第四块信息，找出其工资的信息。</p>

<p>其实基于行式储存，对于where语句处理都需要处理全表。对于磁盘的不停seek，速度就可想而知。当然一般数据库为了应对这种全数据扫描，找到了建立索引的方法。而索引就是对某个或者某些字段的组合的信息，即取出数据的部分信息，以减少每次扫描从全表到部分信息的扫描的过渡。</p>

<p>这种查询方式很适合于一次取出一个行数据，而对于日常应用系统来说这种方式是非常合适的，因为我们设计应用的时候都是针对一个事务，而我们会把一个事务所有属性存储成一行，使用的时候也是有很大的概率涉及到整行的信息，很利于做缓存。还比如我们经常使用的那些经典sql 语句：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="k">user</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1001</span><span class="p">;</span>
</span><span class='line'><span class="k">select</span> <span class="n">id</span><span class="p">,</span> <span class="n">user_name</span><span class="p">,</span> <span class="n">email</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">gender</span><span class="p">,</span> <span class="p">...</span> <span class="k">from</span> <span class="k">user</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1001</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>！！还敢不敢列出些更多的字段！！</p>

<h2>列式储存模型</h2>

<p>而列储存就是下图这种按列优先储存。为了方便我们每块只储存了一个一列，没有存满。
<img src="../images/posts/column_oriented.png" alt="row oriented model" />
这下我们再考虑上面的查找所有Jones的工资，这下我们只扫描第三个磁盘块，找出Jones都再那些行，然后根据查出来的行号，直接去第五块磁盘（这块对应的式salary列）找出第二、四行的数据，然后输出。一共2次seek。大大小于row－oriented的4次。</p>

<p>这种查询方式的前提就是你就需要这列数据就行了，其前提假设就是查询基本不会使用这个行的其他列数据。显然这种假设对于日常操作系统的围绕着一个主题进行的活动是不合适旳。但是却在分析型数据大显身手。</p>

<p>列式的另一大优势是压缩。因为列的天然凝聚性（比如上面的两个Jones就可以压缩成一个）大大强与行，所以列式储存可以有很高的压缩比，这个进一步使使用的磁盘的数量减少，因为使用的磁盘块少，进一步减少了需要扫描的次数。这方面很利于加快查找速度，但是因为解压缩也是耗时耗内存的过程，所以压缩的控制也是需要一个定平衡点。</p>

<h1>优劣总结</h1>

<p>从上面的例子可以明显看出列式数据库在分析需求（获取特点——每次查询几个维度，通常是）时候，不仅<strong>搜索时间效率</strong>占优势，其<strong>空间效率</strong>也是很明显的。特别是针对动辄按T计算的数据量来说，在分布式环境中能进行压缩处理能节省宝贵的内部带宽，从而提高整个计算任务性能。</p>

<p>关于行式和列式的具体优缺点还有具体的使用场景请看wikipedia。</p>

<h1>再来谈谈储存模型</h1>

<p>从上面看，改变物理储存结构对上层操作效率的提高是如此的巨大！所以我们再深入谈谈这个话题。</p>

<p>在数据模型一定的情况下，储存模型也是有多种选择的（想想各种不同数据结构居然提供同样的操作，比如TreeMap和HashMap。数据模型好比Map支持getKey和getValue。而储存模型就是Tree还是HashTable，而getKey和getValue操作虽然对使用者没有区别，但是底层的组织结构则决定了其效率）。而储存模型在数据库这种复杂系统中有分好多层。我们想想先从最底层说起——文件，数据终归都是储存在磁盘上的。而从下面的表格看出，数据要取出必须先进入到内存，那么这个层次的核心就是面对各种查询、写入、更新和删除，怎么快速把数据从磁盘加载到内存中或者反之怎么把数据从内存中快速的写入到磁盘中。</p>

<table>
<thead>
<tr>
<th>用户界面</th>
</tr>
</thead>
<tbody>
<tr>
<td>内存    </td>
</tr>
<tr>
<td>磁盘    </td>
</tr>
</tbody>
</table>


<p>所以先谈谈文件储存有哪些类型：<a href="https://www.tutorialcup.com/dbms/file-organization.htm">File Organization in DBMS</a> 这篇文章对于文件组织在DBMS中的意义讲的非常清楚。这里引出其中对文件组织的要点：</p>

<blockquote><p>Storing the files in certain order is called file organization. The main objective of file organization is</p>

<ul>
<li>Optimal selection of records i.e.; records should be accessed as fast as possible. &ndash; 支持快速的获取</li>
<li>Any insert, update or delete transaction on records should be easy, quick and should not harm other records. &ndash; 支持快读的插入、更新和删除事务</li>
<li>No duplicate records should be induced as a result of insert, update or delete &ndash; 支持键值不重复？？？</li>
<li>Records should be stored efficiently so that cost of storage is minimal. &ndash; 储存占用磁盘空间要小</li>
</ul>
</blockquote>

<p>从上面的目的看，大多数不能同时满足，这样就出现了各种各样的组合选择，所以出现多种组织方式：</p>

<ul>
<li>Sequential File Organization</li>
<li>Heap File Organization</li>
<li>Hash/Direct File Organization</li>
<li>Indexed Sequential Access Method</li>
<li>B+ Tree File Organization</li>
<li>Cluster File Organization
Let us see one by one on clicking the above links</li>
</ul>


<p>Difference between Sequential, heap/Direct, Hash, ISAM, B+ Tree, Cluster file organization in database management system (DBMS) as shown below:</p>

<table>
<thead>
<tr>
<th>          </th>
<th>Sequential</th>
<th> Heap/Direct</th>
<th>Hash </th>
<th>ISAM </th>
<th>B+ tree</th>
<th>Cluster</th>
</tr>
</thead>
<tbody>
<tr>
<td>Method of storing </td>
<td>Stored as they come or sorted as they come </td>
<td>Stored at the end of the file. But the address in the memory is random. </td>
<td>Stored at the hash address generated</td>
<td>Address index is appended to the record </td>
<td>Stored in a tree like structure </td>
<td>Frequently joined tables are clubbed into one file based on cluster key</td>
</tr>
<tr>
<td>疑问</td>
<td>如何做到删除的？</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Types </td>
<td>Pile file and sorted file Method </td>
<td> </td>
<td>Static and dynamic hashing </td>
<td> Dense, Sparse, multilevel </td>
<td>indexing </td>
<td>Indexed and Hash</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Design</td>
<td>Simple Design</td>
<td>Simplest</td>
<td>Medium</td>
<td>Complex</td>
<td>Complex</td>
<td>Simple</td>
</tr>
<tr>
<td>Storage Cost</td>
<td>Cheap (magnetic tapes)</td>
<td>Cheap</td>
<td>Medium</td>
<td>Costlier</td>
<td>Costlier</td>
<td>Medium</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Advantage </td>
<td>Fast and efficient when there is large volumes of data, Report generation, statistical calculations etc</td>
<td>  Best suited for bulk insertion, and small files/tables</td>
<td>Faster Access,No Need to Sort,Handles multiple transactions,Suitable for Online transactions</td>
<td> Searching records is faster.Suitable for large database.Any of the columns can be used as key column.Searching range of data &amp; partial data are efficient.</td>
<td> Searching range of data &amp; partial data are efficient.No performance degrades when there is insert / delete / update.Grows and shrinks with data.Works well in secondary storage devices and hence reducing disk I/O.Since all datas are at the leaf node, searching is easy.All data at leaf node are sorted sequential linked list.</td>
<td>Best suited for frequently joined tables.Suitable for 1:M mappings</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Disadvantage </td>
<td>Sorting of data each time for insert/delete/ update takes time and makes system slow.  </td>
<td>Records are scattered in the memory and they are inefficiently used. Hence increases the memory size.  Proper memory management is needed.  Not suitable for large tables. </td>
<td>Accidental Deletion or updation of Data. Use of Memory is inefficient Searching range of data, partial data, non-hash key column, searching single hash column when multiple hash keys present or frequently updated column as hash key are inefficient. </td>
<td>Extra cost to maintain index. File reconstruction is needed as insert/update/delete.Does not grow with data.  </td>
<td>Not suitable for static tables  </td>
<td>Not suitable for large database. Suitable only for the joins on which clustering is done. Less frequently used joins and 1: 1 Mapping are inefficient.</td>
</tr>
</tbody>
</table>


<h2>Rcfile</h2>

<p>(1) fast data loading
(2) fast query processing
(3) highly efficient storage space utilization
(4) strong adaptivity to highly dynamic workload patterns</p>

<h2>Orcfile</h2>

<h1>refernce</h1>

<ul>
<li><a href="https://www.tutorialcup.com/dbms/file-organization.htm">File Organization in DBMS</a></li>
<li><a href="https://en.wikipedia.org/wiki/Database_storage_structures">Database storage structures</a></li>
<li><a href="http://blog.csdn.net/cjfeii/article/details/8884658">关系型数据在磁盘上的存储布局</a></li>
<li><a href="http://blog.csdn.net/v_july_v/article/details/7526689">从LSM-Tree、COLA-Tree谈到StackOverflow、OSQA</a></li>
<li><a href="http://www.cnblogs.com/siegfang/archive/2013/01/12/lsm-tree.html">日志结构的合并树 The Log-Structured Merge-Tree</a></li>
<li><a href="http://www.cnblogs.com/yurunmiao/p/4745951.html">Hadoop RCFile存储格式详解（源码分析、代码示例）</a></li>
<li><a href="http://web.cse.ohio-state.edu/hpcs/WWW/HTML/publications/papers/TR-11-4.pdf">RCFile: A Fast and Space-efficient Data Placement</a></li>
<li><a href="http://blog.csdn.net/u011955252/article/details/50531178">Rcfile API使用</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Develop Your Own Jdbc Application]]></title>
    <link href="http://woodcarver.github.io/blog/2016/07/18/how-to-develop-your-own-jdbc-application/"/>
    <updated>2016-07-18T10:54:05+08:00</updated>
    <id>http://woodcarver.github.io/blog/2016/07/18/how-to-develop-your-own-jdbc-application</id>
    <content type="html"><![CDATA[<p>刚接触java的小朋友们是不是都发现jdbc这个东西挺好用？所有的数据引擎都完全一致的采用jdbc来连接，这种一致性简直太爽了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Producer-consumer Problem]]></title>
    <link href="http://woodcarver.github.io/blog/2016/07/15/producer-consumer-problem/"/>
    <updated>2016-07-15T23:55:14+08:00</updated>
    <id>http://woodcarver.github.io/blog/2016/07/15/producer-consumer-problem</id>
    <content type="html"><![CDATA[<p>最近在学习多线程编程，周末的时候用java写了一个生产者消费模型，这里做一些记录和总结。</p>

<h2>基本模板</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Producer
</span><span class='line'>  while(true)
</span><span class='line'>    data = generateData()
</span><span class='line'>    queue.enqueue(data)
</span><span class='line'>
</span><span class='line'>Consumer
</span><span class='line'>  while(true)
</span><span class='line'>    data = queue.dequeue()
</span><span class='line'>
</span><span class='line'>main
</span><span class='line'>  sharedQueue = new Queue()
</span><span class='line'>  producer1, producer2 ...
</span><span class='line'>  consumer1, consumer2 ...
</span><span class='line'>  start producer1, producer2 ...
</span><span class='line'>  start consumer1, consumer2 ...
</span><span class='line'>  stop producer1, producer2 ...
</span><span class='line'>  stop consumer1, consumer2 ...</span></code></pre></td></tr></table></div></figure>


<h2>各种错误版</h2>

<h3>最简单版</h3>

<p>这个程序中工作任务很简单就是生产者不断放入一些随机数到队列中，而消费者就是不断取出这些数并打印。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProducerConsumer</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">static</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
</span><span class='line'>
</span><span class='line'>      <span class="kt">int</span> <span class="n">producerNum</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>      <span class="n">Producer</span><span class="o">[]</span> <span class="n">producers</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Producer</span><span class="o">[</span><span class="n">producerNum</span><span class="o">];</span>
</span><span class='line'>      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">producerNum</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">producers</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Producer</span><span class="o">(</span><span class="n">queue</span><span class="o">);</span>
</span><span class='line'>          <span class="n">producers</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">start</span><span class="o">();</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>      <span class="kt">int</span> <span class="n">consumerNum</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
</span><span class='line'>      <span class="n">Consumer</span><span class="o">[]</span> <span class="n">consumers</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Consumer</span><span class="o">[</span><span class="n">consumerNum</span><span class="o">];</span>
</span><span class='line'>      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">consumerNum</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">consumers</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Consumer</span><span class="o">(</span><span class="n">queue</span><span class="o">);</span>
</span><span class='line'>          <span class="n">consumers</span><span class="o">[</span><span class="n">j</span><span class="o">].</span><span class="na">start</span><span class="o">();</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">1000</span><span class="o">);</span>
</span><span class='line'>          <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Main thread is awaken now!&quot;</span><span class="o">);</span>
</span><span class='line'>      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="c1">// TODO Auto-generated catch block</span>
</span><span class='line'>          <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      <span class="c1">// stopping all producers and consumers</span>
</span><span class='line'>      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">producerNum</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">producers</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">stopLoop</span><span class="o">();</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">consumerNum</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">consumers</span><span class="o">[</span><span class="n">j</span><span class="o">].</span><span class="na">stopLoop</span><span class="o">();</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      <span class="c1">// make sure all threads are stopped</span>
</span><span class='line'>      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">producerNum</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>              <span class="n">producers</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">join</span><span class="o">();</span>
</span><span class='line'>              <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Producer: &quot;</span> <span class="o">+</span> <span class="n">producers</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">getId</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot; is stopped!&quot;</span><span class="o">);</span>
</span><span class='line'>          <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>              <span class="c1">// TODO Auto-generated catch block</span>
</span><span class='line'>              <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">consumerNum</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>              <span class="n">consumers</span><span class="o">[</span><span class="n">j</span><span class="o">].</span><span class="na">join</span><span class="o">();</span>
</span><span class='line'>              <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Consumer: &quot;</span> <span class="o">+</span> <span class="n">consumers</span><span class="o">[</span><span class="n">j</span><span class="o">].</span><span class="na">getId</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot; is stopped!&quot;</span><span class="o">);</span>
</span><span class='line'>          <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>              <span class="c1">// TODO Auto-generated catch block</span>
</span><span class='line'>              <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">class</span> <span class="nc">Producer</span> <span class="kd">extends</span> <span class="n">Thread</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">private</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">running</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">long</span> <span class="n">threadId</span><span class="o">;</span> <span class="c1">// 因为每次run之后，才会进入到新的thread</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">static</span> <span class="n">Lock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ReentrantLock</span><span class="o">();</span>
</span><span class='line'>  <span class="kd">public</span> <span class="nf">Producer</span><span class="o">(</span><span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">queue</span> <span class="o">=</span> <span class="n">queue</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="nd">@Override</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">threadId</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getId</span><span class="o">();</span>
</span><span class='line'>      <span class="k">while</span> <span class="o">(</span><span class="n">running</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>              <span class="kt">double</span> <span class="n">item</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">random</span><span class="o">()</span> <span class="o">*</span> <span class="mi">100</span><span class="o">;</span>
</span><span class='line'>              <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span> <span class="c1">// 这里为什么加锁？因为queue我们使用的是LinkedList，所以offer操作不是同步的，不能让不同的生产者互相争抢</span>
</span><span class='line'>              <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">((</span><span class="kt">int</span><span class="o">)</span><span class="n">item</span><span class="o">);</span>
</span><span class='line'>              <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Produce:&quot;</span> <span class="o">+</span> <span class="n">threadId</span> <span class="o">+</span> <span class="s">&quot;--&quot;</span> <span class="o">+</span> <span class="n">item</span><span class="o">);</span>
</span><span class='line'>          <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>              <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span><span class='line'>          <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span><span class='line'>              <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span> <span class="c1">// 放在finally中，保证程序不会中途出错而导致解锁步骤不运行</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">stopLoop</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Stopping Producer -- &quot;</span> <span class="o">+</span> <span class="n">threadId</span><span class="o">);</span>
</span><span class='line'>      <span class="n">running</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="kd">class</span> <span class="nc">Consumer</span> <span class="kd">extends</span> <span class="n">Thread</span> <span class="o">{</span>
</span><span class='line'>  <span class="cm">/**</span>
</span><span class='line'><span class="cm">  * 这版开始加锁，不再出现NullPointerException错误</span>
</span><span class='line'><span class="cm">  * 消费的过程中其实和生产的过程没有冲突，所以只要消费者之间共享一把锁就行了</span>
</span><span class='line'><span class="cm">  * 让queue.peek 和 poll绑定，使之检查是有效的</span>
</span><span class='line'><span class="cm">  */</span>
</span><span class='line'>  <span class="kd">private</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">running</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">static</span> <span class="n">Lock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ReentrantLock</span><span class="o">();</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">long</span> <span class="n">threadId</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">public</span> <span class="nf">Consumer</span><span class="o">(</span><span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">queue</span> <span class="o">=</span> <span class="n">queue</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="nd">@Override</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">threadId</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getId</span><span class="o">();</span>
</span><span class='line'>      <span class="k">while</span> <span class="o">(</span><span class="n">running</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>                  <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span> <span class="c1">// 加锁第一是因为poll非同步，还有peek和poll之间非原子性，不加锁会导致peek检查很容易失效</span>
</span><span class='line'>                      <span class="k">if</span> <span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// double check</span>
</span><span class='line'>                          <span class="kt">int</span> <span class="n">item</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
</span><span class='line'>                          <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Consume:&quot;</span> <span class="o">+</span> <span class="n">threadId</span> <span class="o">+</span><span class="s">&quot; -- &quot;</span> <span class="o">+</span> <span class="n">item</span><span class="o">);</span>
</span><span class='line'>                      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>                          <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Consume:&quot;</span> <span class="o">+</span> <span class="n">threadId</span> <span class="o">+</span><span class="s">&quot; -- empty&quot;</span><span class="o">);</span>
</span><span class='line'>                      <span class="o">}</span>
</span><span class='line'>          <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span><span class='line'>          <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">stopLoop</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Stopping Consumer: &quot;</span> <span class="o">+</span> <span class="n">threadId</span><span class="o">);</span>
</span><span class='line'>      <span class="n">running</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>开始点评这个版本：
- 巨大的缺点就是queue是无界的，很容易造成queue被爆掉
- running这个变量非同步，所以在主线程中调用stopLoop虽然可能生效，但是按照java的内存模型来说，没有同步的变量在不同线程中可能不能被互相观察到，这导致consumer的线程都观察不到running已经被主线程设置为false了。从而导致程序停不下来（查看<a href="https://www.amazon.cn/Sun-%E5%85%AC%E5%8F%B8%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6-Effective-Java%E4%B8%AD%E6%96%87%E7%89%88-Joshua-Bloch/dp/B001PTGR52/ref=sr_1_1?ie=UTF8&amp;qid=1468729174&amp;sr=8-1&amp;keywords=effective+java">Effective java的66条</a>）。解决这个问题有两种方法，一种是使用synchronized修饰的方法来封装running的读写，一种是把running秀事成volatile（参看<a href="https://www.amazon.cn/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E5%91%A8%E5%BF%97%E6%98%8E/dp/B00D2ID4PK/ref=sr_1_1?ie=UTF8&amp;qid=1468728884&amp;sr=8-1&amp;keywords=jvm">深入理解Java虚拟机:JVM高级特性与最佳实践</a>）。</p>

<h3>queue实现有界版</h3>

<p>自己利用LinkedList实现了一个BlockQueue，当然java中本身就有个这个而数据结构，这个造轮子只是为了理解其中的原理。
这次这个程序稍微复杂一些，存取的不在是随机数，而是一个个log。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * 1、第一版的时候我们只用了linkedlist来模拟queu，但是让出现producer特别慢，但是consumer又总是再探测浪费资源？</span>
</span><span class='line'><span class="cm"> * 2、还有就是producer产生速度过去快，难道就让它把内存挤爆吗？</span>
</span><span class='line'><span class="cm"> * 3、所以我们需要blockingQueue，第一是限制queue的大小，第二是协调两方的生产和消费速度。</span>
</span><span class='line'><span class="cm"> * @author xiedandan</span>
</span><span class='line'><span class="cm"> *</span>
</span><span class='line'><span class="cm"> * 疑问点：使用monitor来设计一个blocking Queue</span>
</span><span class='line'><span class="cm"> * 1. 不对queue进行synchronize，会爆出IllegalMonitorException</span>
</span><span class='line'><span class="cm"> * 2. 然后开始不断调整synchronize位置，比如在while(running)外边，在while(running)里面</span>
</span><span class='line'><span class="cm"> * 3. 然后就开了怎么都唤不醒consumer的bug</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProducerConsumerBlockingQueue</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">static</span> <span class="n">SudoBlockingQueue</span><span class="o">&lt;</span><span class="n">Log</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="c1">// 和格版本一致</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="cm">/* mimic a bin-log restore system.</span>
</span><span class='line'><span class="cm"> * Producer to produce operating logs and consumer to read the logs and try to restore the record.</span>
</span><span class='line'><span class="cm"> * log schema: transactionId, operatingType, dataValue(before current operation)</span>
</span><span class='line'><span class="cm"> *</span>
</span><span class='line'><span class="cm"> * version 1: Suppose we only have one row record in whole table and only add operation,</span>
</span><span class='line'><span class="cm"> *             so the log order is not important.</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kd">class</span> <span class="nc">ProducerLog</span> <span class="kd">extends</span> <span class="n">Thread</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">private</span> <span class="n">SudoBlockingQueue</span><span class="o">&lt;</span><span class="n">Log</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">boolean</span> <span class="kd">volatile</span> <span class="n">running</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">long</span> <span class="n">threadId</span><span class="o">;</span>
</span><span class='line'>  <span class="c1">// private Lock lock; // 1. 为啥在这里我们不用lock呢？因为都封装在queue自身中了。</span>
</span><span class='line'>  <span class="kd">public</span> <span class="nf">ProducerLog</span><span class="o">(</span><span class="n">SudoBlockingQueue</span><span class="o">&lt;</span><span class="n">Log</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">queue</span> <span class="o">=</span> <span class="n">queue</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="nd">@Override</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">threadId</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getId</span><span class="o">();</span>
</span><span class='line'>      <span class="k">while</span><span class="o">(</span><span class="n">running</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>              <span class="kd">synchronized</span><span class="o">(</span><span class="n">queue</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 2. 试试把这句话取掉会产生结果？</span>
</span><span class='line'>      <span class="c1">//         1.if (queue.isFull()) { // 3. 为什么不能使用if，而要使用while？</span>
</span><span class='line'>                  <span class="k">while</span> <span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">isFull</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>                      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Proudce:&quot;</span> <span class="o">+</span> <span class="n">threadId</span> <span class="o">+</span> <span class="s">&quot;--- wait&quot;</span><span class="o">);</span>
</span><span class='line'>                      <span class="n">queue</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
</span><span class='line'>                  <span class="o">}</span>
</span><span class='line'>                  <span class="kt">boolean</span> <span class="n">e</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>
</span><span class='line'>                  <span class="n">Log</span> <span class="n">log</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Log</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="n">Math</span><span class="o">.</span><span class="na">random</span><span class="o">()</span> <span class="o">*</span> <span class="mi">100</span><span class="o">));</span>
</span><span class='line'>                  <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Proudce:&quot;</span> <span class="o">+</span> <span class="n">threadId</span> <span class="o">+</span> <span class="s">&quot;---&quot;</span> <span class="o">+</span> <span class="n">log</span><span class="o">);</span>
</span><span class='line'>                  <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">log</span><span class="o">);</span>
</span><span class='line'>                  <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Proudce:&quot;</span> <span class="o">+</span> <span class="n">threadId</span> <span class="o">+</span> <span class="s">&quot;--- notify all&quot;</span><span class="o">);</span>
</span><span class='line'>                      <span class="n">queue</span><span class="o">.</span><span class="na">notifyAll</span><span class="o">();</span>
</span><span class='line'>                  <span class="o">}</span>
</span><span class='line'>              <span class="o">}</span>
</span><span class='line'>          <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>              <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">stopLoop</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Stopping Prouder:&quot;</span> <span class="o">+</span> <span class="n">threadId</span><span class="o">);</span>
</span><span class='line'>      <span class="n">running</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>      <span class="n">queue</span><span class="o">.</span><span class="na">syncNotifyAll</span><span class="o">();</span> <span class="c1">// 4. 为啥这里还有再次notifyall一次呢？</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="kd">class</span> <span class="nc">ConsumerLog</span> <span class="kd">extends</span> <span class="n">Thread</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">private</span> <span class="n">SudoBlockingQueue</span><span class="o">&lt;</span><span class="n">Log</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">running</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">long</span> <span class="n">threadId</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">public</span> <span class="nf">ConsumerLog</span><span class="o">(</span><span class="n">SudoBlockingQueue</span><span class="o">&lt;</span><span class="n">Log</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">queue</span> <span class="o">=</span> <span class="n">queue</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="nd">@Override</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">threadId</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getId</span><span class="o">();</span>
</span><span class='line'>      <span class="k">while</span><span class="o">(</span><span class="n">running</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>              <span class="kd">synchronized</span><span class="o">(</span><span class="n">queue</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                  <span class="k">while</span> <span class="o">(</span><span class="n">running</span> <span class="o">&amp;&amp;</span> <span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>                      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Consumer:&quot;</span> <span class="o">+</span> <span class="n">threadId</span> <span class="o">+</span> <span class="s">&quot;--wait&quot;</span><span class="o">);</span>
</span><span class='line'>                      <span class="n">queue</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
</span><span class='line'>                  <span class="o">}</span>
</span><span class='line'>                  <span class="kt">boolean</span> <span class="n">f</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">isFull</span><span class="o">();</span>
</span><span class='line'>                  <span class="n">Log</span> <span class="n">log</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
</span><span class='line'>                  <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Consumer:&quot;</span> <span class="o">+</span> <span class="n">threadId</span> <span class="o">+</span> <span class="s">&quot;--&quot;</span> <span class="o">+</span> <span class="n">log</span><span class="o">);</span>
</span><span class='line'>                  <span class="k">if</span> <span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Consumer:&quot;</span> <span class="o">+</span> <span class="n">threadId</span> <span class="o">+</span> <span class="s">&quot;--notify&quot;</span><span class="o">);</span>
</span><span class='line'>                      <span class="n">queue</span><span class="o">.</span><span class="na">notifyAll</span><span class="o">();</span>
</span><span class='line'>                  <span class="o">}</span>
</span><span class='line'>              <span class="o">}</span>
</span><span class='line'>          <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>              <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">stopLoop</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Stopping Consumer -- &quot;</span> <span class="o">+</span> <span class="n">threadId</span><span class="o">);</span>
</span><span class='line'>      <span class="n">running</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>      <span class="n">queue</span><span class="o">.</span><span class="na">syncNotifyAll</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="kd">class</span> <span class="nc">Log</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">int</span> <span class="n">tranId</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">int</span> <span class="n">operaType</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">int</span> <span class="n">data</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">public</span> <span class="nf">Log</span><span class="o">(</span><span class="kt">int</span> <span class="n">tranId</span><span class="o">,</span> <span class="kt">int</span> <span class="n">operaType</span><span class="o">,</span> <span class="kt">int</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">tranId</span> <span class="o">=</span> <span class="n">tranId</span><span class="o">;</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">operaType</span> <span class="o">=</span> <span class="n">operaType</span><span class="o">;</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="nd">@Override</span>
</span><span class='line'>  <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="s">&quot;TranId:&quot;</span> <span class="o">+</span> <span class="n">tranId</span> <span class="o">+</span> <span class="s">&quot;,OperaType:&quot;</span> <span class="o">+</span> <span class="n">operaType</span> <span class="o">+</span> <span class="s">&quot;,Data&quot;</span> <span class="o">+</span> <span class="n">data</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="kd">class</span> <span class="nc">SudoBlockingQueue</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="mi">13344L</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">CAPACITY</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">public</span> <span class="nf">SudoBlockingQueue</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">CAPACITY</span> <span class="o">=</span> <span class="n">capacity</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="kt">boolean</span> <span class="nf">isFull</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="n">CAPACITY</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="kt">int</span> <span class="nf">getCapacity</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">CAPACITY</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">syncNotifyAll</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">notifyAll</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">syncWait</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">this</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
</span><span class='line'>      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="c1">// TODO Auto-generated catch block</span>
</span><span class='line'>          <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>回答上面的问题：</p>

<ol>
<li>为什么要对queue进行同步呢？原因之一是是前一个例子一样lock的作用，同步offer的。还有一个重要的原因是queue.wait()和queue.notify()必须在拥有当前queue的控制权时候才能进行。不然会报IllegalMonitorStateException(关于为什么会产生这个异常，参看<a href="http://www.cnblogs.com/techyc/p/3272321.html">Java的wait(), notify()和notifyAll()使用小结</a>)。</li>
<li>为什么不能使用if，而要使用while？原因是为了double check，想想有3个消费者，其生产的消费速度远远大于生产速度。当一个任务被生产出来，唤醒了全部的consumers，这时候多个consumer准备结束queue.wait()。但是只有一个consumer能抢到资源，其他的consumer如果不再次做isEmpty检查就会误以为任务，继续走下去，结果发生错误。一定参看这篇文章：<a href="http://www.importnew.com/16453.html">如何在 Java 中正确使用 wait, notify 和 notifyAll – 以生产者消费者模型为例</a></li>
<li>为啥这里还有再次notifyAll一次呢？因为当stop的时候有些线程正处于wait装填，必须唤醒才能从while(running)跳出来。因为notifyAll需要保证获得queue的控制权，所以需要synchronized。</li>
</ol>


<p>这个版本设计的也比较糟糕，因为需要调用多次的stopLoop，可以把running设计成static，只用调用一次stopLoop即可。</p>

<h2>关于 wait(), notify() and notifyAll()的一些理解</h2>

<ul>
<li>这些是都是一个Monitor同步模型的一些具体操作。<a href="http://www.javamadesoeasy.com/2015/03/why-wait-notify-and-notifyall-are-in.html">下面引用这篇文章</a></li>
<li>Every Object has a monitor, acquiring that monitors allow thread to hold lock on object. But Thread class does not have any monitors.</li>
<li><p>wait(), notify() and notifyAll() are called on objects only > When wait() method is called on object by thread it waits for another thread on that object to release object monitor by calling notify() or notifyAll() method on that object.
When notify() method is called on object by thread it notifies all the threads which are waiting for that object monitor that object monitor is available now.
So, this shows that wait(), notify() and notifyAll() are called on objects only.
Now, Straight forward question that comes to mind is how thread acquires object lock by acquiring object monitor? Let’s try to understand this basic concept in detail?</p></li>
<li><p>Wait(), notify() and notifyAll() method being in Object class allows all the threads created on that object to communicate with other.  [As multiple threads may exist on same object].</p></li>
<li><p>As multiple threads exists on same object. Only one thread can hold object monitor at a time. As a result thread can notify other threads of same object that lock is available now. But, thread having these methods does not make any sense because multiple threads exists on object it&rsquo;s not other way around (i.e. multiple objects exists on thread).</p></li>
<li><p>Now let’s discuss one hypothetical scenario, what will happen if Thread class contains wait(), notify() and notifyAll() methods?
Having wait(), notify() and notifyAll() methods means Thread class also must have their monitor.
Every thread having their monitor will create few problems -</p>

<blockquote><p>Thread communication problem.
Synchronization on object won’t be possible- Because object has monitor, one object can have multiple threads and thread hold lock on object by holding object monitor. But if each thread will have monitor, we won’t have any way of achieving synchronization.
Inconsistency in state of object (because synchronization won&rsquo;t be possible).</p></blockquote></li>
</ul>


<h2>写正确一个并发程序真实不容易，特别容易遇到各种死锁而结束不了程序。学会并发编程：</h2>

<ol>
<li><a href="./">生产者消费模型</a></li>
<li><a href="./">线程池</a></li>
<li><a href="./">进程池</a></li>
<li><a href="./">LRU缓存</a></li>
</ol>


<h3>refenrence</h3>

<ul>
<li><a href="http://www.importnew.com/10173.html">notify和notifyAll的一段代码分析</a></li>
<li><a href="http://stackoverflow.com/questions/20110013/implement-your-own-blocking-queue-in-java">implement-your-own blocking queue in java</a></li>
<li><a href="http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/locks/Condition.html">Interface Condition</a></li>
<li><a href="http://www.importnew.com/16453.html">如何在 Java 中正确使用 wait, notify 和 notifyAll – 以生产者消费者模型为例</a></li>
<li><a href="http://www.cnblogs.com/techyc/p/3272321.html">Java的wait(), notify()和notifyAll()使用小结</a></li>
<li><a href="http://www.ticmy.com/?p=219"></a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why Many Data Structrues Have Logn Relative Time Complexity]]></title>
    <link href="http://woodcarver.github.io/blog/2016/07/07/why-many-data-structrues-have-logn-relative-time-complexity/"/>
    <updated>2016-07-07T21:50:55+08:00</updated>
    <id>http://woodcarver.github.io/blog/2016/07/07/why-many-data-structrues-have-logn-relative-time-complexity</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduce Redis]]></title>
    <link href="http://woodcarver.github.io/blog/2016/07/07/introduce-redis/"/>
    <updated>2016-07-07T21:35:59+08:00</updated>
    <id>http://woodcarver.github.io/blog/2016/07/07/introduce-redis</id>
    <content type="html"><![CDATA[<p>观点一：redis采用结构化数据，打通了代码和储存
关键技术： event loop， single thread</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Desgin a Thread Pool]]></title>
    <link href="http://woodcarver.github.io/blog/2016/06/22/how-to-desgin-a-thread-pool/"/>
    <updated>2016-06-22T23:11:22+08:00</updated>
    <id>http://woodcarver.github.io/blog/2016/06/22/how-to-desgin-a-thread-pool</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
</feed>
