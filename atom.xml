<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Wood Carver]]></title>
  <link href="http://woodcarver.github.io/atom.xml" rel="self"/>
  <link href="http://woodcarver.github.io/"/>
  <updated>2016-09-16T12:12:35+08:00</updated>
  <id>http://woodcarver.github.io/</id>
  <author>
    <name><![CDATA[Wood Carver]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Learning How to Learn]]></title>
    <link href="http://woodcarver.github.io/blog/2016/09/14/learning-how-to-learn/"/>
    <updated>2016-09-14T16:40:30+08:00</updated>
    <id>http://woodcarver.github.io/blog/2016/09/14/learning-how-to-learn</id>
    <content type="html"><![CDATA[<p>《Learning how to learn》是一门coursera上一门优秀的课程，已经开播很多期。我在这里开始把这门课程以自己的方式翻译成中文版。希望能给大家带来一些学习方法上的收获，提升大家的学习效率。</p>

<h1>第一章： 大脑中的两种思维方式——聚焦式（focused modes）和发散式（Diffuse modes）</h1>

<p>当你想不出来一个问题的答案时候你会怎么做？对于僵尸来说，那可件简单的事情。他们可以通过不断的把脑袋往墙上撞就可以了。但是活着的大脑则是相当复杂的。事实表明，如果你能多了解一点大脑的工作过程，你将会把学习变得轻松很多，同事少很多挫败感。</p>

<p>万能的研究人员发现我们人类大脑一般有两种思考方式，一种是聚焦式思考方式，另一种是发散式思考方式。
我们非常熟悉聚焦式思考方式，这种方式是通过集中注意力在正在学习和理解的东西上。但是我们不太熟悉发散式方式，这种方式是通过关联一组正在休息的神经元细胞。</p>

<p>我们将通过一个<strong>弹球游戏(pinball game)</strong>的打比来让大家理解这两种思考方式。顺便说
一下，象征和比喻是一种强大的工具来让我们理解一些要学习的东西。</p>

<p><img src="http://woodcarver.oss-cn-shanghai.aliyuncs.com/post/learning_how_to_learn/pinball.png" alt="pinball" /></p>

<p>pinball的内部则充满着小柱子，这个游戏的基本规则是你通过拨动一个弹簧然后射出一个小球，使它达到目的地小柱子上。现在到你的大脑，你的眼睛在前面，耳朵在两旁，然后你的大脑就是pinball内部结构。</p>

<p>下面的图是focused mode的比喻：
<img src="http://woodcarver.oss-cn-shanghai.aliyuncs.com/post/learning_how_to_learn/focused_mode.png" alt="focused mode" /></p>

<p>我们发现其有一些线已经连通了一些柱子，而且这些柱子之间的距离都非常近。看着图中的橘黄色的线，它就代表着一个熟悉的思考模式，也许代表着简单的加法。你在想一些事情，小球就会从底部的小点出发，移动到大脑的里面，然后开始搜索，如果到了小蓝柱子之间有橘黄色连线的时候，思考是非常容易的，因为每个柱子之间距离非常近，还有现成的连线可以达到。</p>

<p>这是一个相当愉快的又熟悉的过程。但是如果我们要到一个熟悉的地方怎么办？比如我们要获得一个新的想法（idea）或者一个新的方法的时候。你既不知道它在哪里，也不知道它长什么样子。例如下图：
<img src="http://woodcarver.oss-cn-shanghai.aliyuncs.com/post/learning_how_to_learn/how_to_reach_new_things.png" alt="how_to_reach_new_things.png" /></p>

<p><strong>你怎么到达下面的绿色连线的部分？（那句是答案）</strong></p>

<p>这就是一个典型的如果你要获得什么东西，你首先需要创建它。而通常创建东西的方法和使用东西的方法不一样。这时候就引出了发散式思维方式。
<img src="http://woodcarver.oss-cn-shanghai.aliyuncs.com/post/learning_how_to_learn/different_in_diffuse_mode.png" alt="different_in_diffuse_mode.png" /></p>

<p>我们看到在这种思维下，你看问题的方式会非常不一样。小球会要穿越非常长的距离，而且跨越的范围也非常大。在你的大脑里，你可以创建新的神经元模式在移动小球的过程中。在diffuse mode里面，你思考问题非常广泛。这时候你不能把注意力集中在一起，反而是一种全图景象（big-picture）的过程。这种思考方式不是让你得到一个问题的答案，但是可以至少给你一个解决方案的粗糙的原始方案。</p>

<p>现在神经学科学家发现，你不可能同时处于两种思考模式，而是只能选择其一。这就像一个硬币，要么翻到正面，要么翻到反面，但是不可能两面同时出现。</p>

<p>了解两种不同的思维方式，后面的课程会介绍怎么<strong>正确</strong>的这两种思考方式来达到最好的学习效果。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Data File Organization]]></title>
    <link href="http://woodcarver.github.io/blog/2016/09/04/data-file-organization/"/>
    <updated>2016-09-04T17:01:19+08:00</updated>
    <id>http://woodcarver.github.io/blog/2016/09/04/data-file-organization</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduce Hive]]></title>
    <link href="http://woodcarver.github.io/blog/2016/08/31/introduce-hive/"/>
    <updated>2016-08-31T22:57:57+08:00</updated>
    <id>http://woodcarver.github.io/blog/2016/08/31/introduce-hive</id>
    <content type="html"><![CDATA[<h1>Rcfile的设计</h1>

<ul>
<li>key/value</li>
<li>column-store and row-store , why?
row-store: fast loading data in real-time in HDFS, because data coming by row and will be stored in one place event in one block. But it can not support fast ad-hoc query.</li>
</ul>


<p>怎么衡量一个文件组织方式？答案只有一个，那就是它满不满足使用性能？
好的，对于一个文件我们要做的事情无非就是：读，写。
读有又，位置和数据大小的特性。比如按位置划分就有随机读，顺序读，逆序读等等，大小就是读一条数据，一片数据。再把位置和大小一结合，呵呵！是不是很复杂？
对于hive来说，其读特性就是：读一行也行，读一列也快，还有更牛的是还能建立索引。</p>

<p>写的话，也有位置和大小之分。随机写，在头位置写，在未位置写。大小写入一条数据，写入一片数据。再一结合。。。。</p>

<p>hive写的就是追加，这也是为什么要先水平在垂直，要的就是加载数据速度，还有实时加载数据的特性。因为打开一个节点的比打开无数节点靠谱很多不是吗？还往单机上说，就是打开一个文件总比打开多个文件写要快不是吗？
同时如果写操作是流式的，那么每次写入其实都需要重新组织数组块，进行压缩。</p>

<p>如果把读和写结合起来就产生了更邪恶的操作，那就是删除和更新。</p>

<h1>HSQL怎么解析到MapReduce？</h1>

<h2>怎么使用MapReduce实现Join？</h2>

<h2>怎么使用MapReduce实现Group By？</h2>

<h2>怎么使用MapReduce实现Distinct？</h2>

<h1>如何在Hive中加载一个外部的脚本文件？</h1>

<h1>写UDF, UDAF, UDTF</h1>

<p>Hive提供UDF, UDAF, UDTF三种接口来给用户扩展sql的功能。当然为什么要有三个接口呢？他们有什么区别？这个我们下面会依次讲到。</p>

<p>首先我们需要知道现在都有哪些实现好的函数，就不用再造轮子了是吧！</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; show functions;
</span><span class='line'>!  
</span><span class='line'>!=  
</span><span class='line'>......
</span><span class='line'>
</span><span class='line'>&gt; describe function max;</span></code></pre></td></tr></table></div></figure>


<p>show functions这个命令可以列出现有的函数，而describe function function-name会列出具体的函数描述。</p>

<p>写自己的函数前，我们先要明确下我们的函数到底会怎么被Hive运行？会在那个阶段运行？这个就不得不说SQL语句的解析了。一般SQL的解析顺序是：</p>

<ul>
<li>from</li>
<li>where</li>
<li>group by</li>
<li>having</li>
<li>select</li>
<li>distinct</li>
<li>union</li>
<li>order by</li>
<li>limit</li>
</ul>


<p>本质上SQL是一个种集合代数运算操作的语言，每一种操作都是一种代数操作。
这个顺序基本可以这么理解：首先需要确定数据源（from后面的表），然后数据确定范围（where条件筛选），然后对这个数据进行分组（group），然后选择要展示的列（select），然后可以对选择的数据集进行排序（order by）。后面如果还有一个数据集那么可以union。其中还有像having，distinct和limit操作的顺序我暂时还不能理解这里就不讲了，还有发现distinct的执行顺序和group by并不在一起让而且在select后面，也许这里就会产生一些写法上的注意点。其中这个排序也可能在不同的数据库引擎中执行顺序不一样。
具体详情参看<a href="http://blog.jobbole.com/55086/">这篇文章</a>。</p>

<p>那么hive的函数要做到在SQL语句哪个部分都能运行，所以对函数的语义一定要弄清楚。而且一定要把函数处理过程想想成流式的，因为在SQL中所有的操作都是流式操作。</p>

<ol>
<li>UDF只能实现一进一出的操作, 即UDF只能操作一行的数据，而要操作多行的数据需要使用UDAF实现</li>
<li>实现聚合函数请用UDAF， 解决进多出一</li>
<li>UDTF(User-Defined Table-Generating Functions) 用来解决 输入一行输出多行(On-to-many maping) 的需求</li>
</ol>


<h2>怎么解决hive中的数据倾斜问题</h2>

<h2>hive sql优化</h2>

<ul>
<li>裁剪列，不要写不查的列</li>
<li>裁剪分区，如果是子查询限制条件一般放在子查询内部</li>
<li>Join1 —— 小表前置，想想hash join的过程</li>
<li>Join2 ——</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Design Pattern]]></title>
    <link href="http://woodcarver.github.io/blog/2016/08/22/design-pattern/"/>
    <updated>2016-08-22T23:00:57+08:00</updated>
    <id>http://woodcarver.github.io/blog/2016/08/22/design-pattern</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Manipulate Binary Stream]]></title>
    <link href="http://woodcarver.github.io/blog/2016/08/14/how-to-manipulate-binary-stream/"/>
    <updated>2016-08-14T20:47:13+08:00</updated>
    <id>http://woodcarver.github.io/blog/2016/08/14/how-to-manipulate-binary-stream</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Use Jmock]]></title>
    <link href="http://woodcarver.github.io/blog/2016/08/14/how-to-use-jmock/"/>
    <updated>2016-08-14T14:35:32+08:00</updated>
    <id>http://woodcarver.github.io/blog/2016/08/14/how-to-use-jmock</id>
    <content type="html"><![CDATA[<p><a href="http://www.jmock.org/expectations.html">jmock官网</a></p>

<h1>测试框架</h1>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void testSomeAction() {
</span><span class='line'>    ... set up ...
</span><span class='line'>
</span><span class='line'>    context.checking(new Expectations()
</span><span class='line'>        ... expectations go here ...
</span><span class='line'>    );
</span><span class='line'>
</span><span class='line'>    ... code being tested ...
</span><span class='line'>
</span><span class='line'>    context.assertIsSatisfied();
</span><span class='line'>
</span><span class='line'>    ... other assertions ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>其中最重要的一个步骤就是context.checking。这个方法中定义的expectation就是需要关注的。也就是你要模拟的方法的输入和输出。
其他格式是这样的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>invocation-count (mock-object).method(argument-constraints);
</span><span class='line'>    inSequence(sequence-name);
</span><span class='line'>    when(state-machine.is(state-name));
</span><span class='line'>    will(action);
</span><span class='line'>    then(state-machine.is(new-state-name));</span></code></pre></td></tr></table></div></figure>


<p>其每个短语的具体意思如下：</p>

<table>
<thead>
<tr>
<th>one    </th>
<th>The invocation is expected once and once only.</th>
</tr>
</thead>
<tbody>
<tr>
<td>exactly(n).of</td>
<td> The invocation is expected exactly n times. Note: one is a convenient shorthand for exactly(1).</td>
</tr>
<tr>
<td>atLeast(n).of </td>
<td>The invocation is expected at least n times.</td>
</tr>
<tr>
<td>atMost(n).of   </td>
<td>The invocation is expected at most n times.</td>
</tr>
<tr>
<td>between(min, max).of   </td>
<td>The invocation is expected at least min times and at most max times.</td>
</tr>
<tr>
<td>allowing   </td>
<td>The invocation is allowed any number of times but does not have to happen.</td>
</tr>
<tr>
<td>ignoring   </td>
<td>The same as allowing. Allowing or ignoring should be chosen to make the test code clearly express intent.</td>
</tr>
<tr>
<td>never  </td>
<td>The invocation is not expected at all. This is used to make tests more explicit and so easier to understand.</td>
</tr>
</tbody>
</table>


<p>所有的函数都是可以选的，例如你可以如下组合你的exception。</p>

<h1>例子</h1>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void testReturnsCachedObjectWithinTimeout() {
</span><span class='line'>    context.checking(new Expectations()
</span><span class='line'>        oneOf (clock).time(); will(returnValue(loadTime));
</span><span class='line'>        oneOf (clock).time(); will(returnValue(fetchTime));
</span><span class='line'>
</span><span class='line'>        allowing (reloadPolicy).shouldReload(loadTime, fetchTime); will(returnValue(false));
</span><span class='line'>
</span><span class='line'>        oneOf (loader).load(KEY); will(returnValue(VALUE));
</span><span class='line'>    );
</span><span class='line'>
</span><span class='line'>    Object actualValueFromFirstLookup = cache.lookup(KEY);
</span><span class='line'>    Object actualValueFromSecondLookup = cache.lookup(KEY);
</span><span class='line'>
</span><span class='line'>    context.assertIsSatisfied();
</span><span class='line'>    assertSame("should be loaded object", VALUE, actualValueFromFirstLookup);
</span><span class='line'>    assertSame("should be cached object", VALUE, actualValueFromSecondLookup);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduce CAP]]></title>
    <link href="http://woodcarver.github.io/blog/2016/07/29/introduce-cap/"/>
    <updated>2016-07-29T10:04:53+08:00</updated>
    <id>http://woodcarver.github.io/blog/2016/07/29/introduce-cap</id>
    <content type="html"><![CDATA[<p>这篇博文主要是对<a href="http://www.infoq.com/cn/articles/cap-twelve-years-later-how-the-rules-have-changed/">《CAP理论十二年回顾："规则"变了》</a>的读后感。</p>

<h1>CAP到底讲什么，为什么不能同时满足？</h1>

<p>首先明确一点，CAP是一个分布式系统的特性，如果你没有多个服务节点，就不可能发生分区。先解释下概念：
- C —— 执行的结果能同时反映到所有节点上。等同于所有节点访问同一份最新的数据副本。也许这里需要很多的具体不变性约束，比如主键不能重复。
- A —— 这个是指访问的节点是正常的，那么就能正常执行请求（所以和P的一个冲突点就是当系统部分失效，这个系统到底是判定为失效还是正常？）
- P —— 这个特性是说当系统的节点之间通信出现了问题，导致之间不能同步，然后还能继续提供服务。
其实我第一次读这个概念，就是不明白为啥这三个方面不能全部同时获得。然后看了个这个例子：</p>

<blockquote><p>理解CAP理论的最简单方式是想象两个节点分处分区两侧。允许至少一个节点更新状态会导致数据不一致，即丧失了C性质。如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了A性质。除非两个节点可以互相通信，才能既保证C又保证A，这又会导致丧失P性质。一般来说跨区域的系统，设计师无法舍弃P性质，那么就只能在数据一致性和可用性上做一个艰难选择。不确切地说，NoSQL运动的主题其实是创造各种可用性优先、数据一致性其次的方案；而传统数据库坚守ACID特性（原子性、一致性、隔离性、持久性），做的是相反的事情。下文“ACID、BASE、CAP”小节详细说明了它们的差异。</p></blockquote>

<p>上面的例子说的太清楚了，当分布式系统发生了节点之间通信失败，就相当于一个整体的服务发生断裂，分成了几个服务块。从而丢失了其对等性（即从任意一个节点都可以访问到整个系统）。然后这个时候如果其中一部分提供服务，比如写操作通过一节点写入了，但是因为不能通信没有办法复制到其他节点，导致了系统的不一致性。这样就就丢失了C，但是还好保住了A。
接着如果要追求C，那么只有等节点之间的通信成功才行，那么就需要写入操作延迟或者这个期间拒绝服务。那么都不能服务了，自然就没有了A。</p>

<p>所以来说当没有发生分区的时候，C和A可以完美保持。但是发生了分区，那么要容错，C和A可能就不能同时保持。
其实这不是一个3选2的问题，因为你没办法选择系统不分区，当通信出问题这个是能选择的吗？这个是故障，你有办法选择故障？所以其实所有的分布式系统都是在C和A之间进行设计权责。</p>

<h1>C和A之间选择不是0和1的选择，而是一种连续式选择</h1>

<p>从上面的例子看，好像选择C就必须放弃A，反之亦然。但是其实所有这些都有中间方案。C和A的定义也有各种灰度定义。
比如C的定义，最严格的定义就是一个分布式事务结束后，所有的副本在任何时刻都是一致的。但是这个定义可以放宽。时间不在是同时，而是一段时间，给一个时间窗口。或者一阶段内可以不一致，但最终变成一致的。比如上面的例子中，在发生分区的时候，可以暂时不一致，等到通信问题解决了，开始恢复一致性。</p>

<p>而对于A的定义来说，也是有各种层次，在发生分区的时候，可以选择限制部分操作，同时提供一个些事后比较好恢复的操作。</p>

<h1>一种经典的系统设计模式</h1>

<p>因为在分布式系统中，基本是没有办法选择不要分区的，所以为了保证系统的可用性，和一致性的博弈，经典的设计模式就是分情况对待。当不发生分区的时候保证完美的CA，到出现了分区，进入分区模式，等待分区恢复后，恢复系统，最终达到一致性后，再次进入完美CA状态。</p>

<p><img src="../images/posts/CAP1.png" alt="" /></p>

<ul>
<li>检测到分区开始</li>
<li>明确进入分区模式，限制某些操作，并且</li>
<li>当通信恢复后启动分区恢复过程</li>
</ul>


<p>最后一步的目的是恢复一致性，以及补偿在系统分区期间程序产生的错误。</p>

<p>当系统进入到分区模式，它有两种可行的策略。其一是限制部分操作，因此会削弱可用性。其二是额外记录一些有利于后面分区恢复的操作信息。系统可通过持续尝试恢复通信来察觉分区何时结束。</p>

<h1>副本</h1>

<p>一谈到副本，最大的问题就是其一致性，这个问题不仅仅是在分布式系统中涉及，只不过分布式系统是鼓励副本的存在，而在这个基础上开始设计一套一套的解决方案。但相对其他领域——比如设计模式OOD，关系数据范式都是从另一个方向把<strong>重复（副本）扼杀在摇篮中</strong>，比如策略模型，把能公用的都抽象出来复用。</p>

<h1>可怕的一致性</h1>

<ol>
<li>一个场景，一个问题</li>
<li>如何解决这个问题？</li>
<li>这个解决方法是错的吗？</li>
<li>这个方法是对的吗？</li>
<li><p>有没有更优的解法？</p></li>
<li><p>隐喻，一个直观的例子</p></li>
<li>过度到实际的模型</li>
<li>证明模型</li>
<li>实际用途</li>
</ol>


<h1>reference</h1>

<ul>
<li><a href="https://martin.kleppmann.com/2015/05/11/please-stop-calling-databases-cp-or-ap.html">Please stop calling databases CP or AP</a></li>
<li><a href="https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed">CAP Twelve Years Later: How the &ldquo;Rules&rdquo; Have Changed
</a></li>
<li><a href="http://www.cnblogs.com/esingchan/p/3917718.html">分布式理论之一：Paxos算法的通俗理解</a></li>
<li><a href="http://www.cnblogs.com/endsock/p/3480093.html">Paxos算法细节详解(一)&ndash;通过现实世界描述算法</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何理解一个数据存储系统]]></title>
    <link href="http://woodcarver.github.io/blog/2016/07/24/how-to-understand-a-database/"/>
    <updated>2016-07-24T14:57:42+08:00</updated>
    <id>http://woodcarver.github.io/blog/2016/07/24/how-to-understand-a-database</id>
    <content type="html"><![CDATA[<h1>储存系统的目的</h1>

<p>其实储存系统的目的估计和文件系统没什么两样，就是存储数据并且取出数据。关键的两个操作还是 <strong>write/read</strong>。但是说差异巨大也是合理的，因为因为文件系统的是面向<strong>文件</strong>的，而对数据的结构和信息是隐藏起来，可以说毫不关心数据的特质，全部打包放在一起。而数据储存系统而转换了问题的角度，把主角换成了<strong>数据</strong>，提供数据的特定的组织方式，针对不同结果的组织给出方便的获取和写入方式。</p>

<p>说明其不同，让我们看一个例子。拿最常数的用户表说明，如果我们建立的一个网站，提供用户注册留言。
设想我们没有数据库，只能存储文件，那么我们就会这么存储：</p>

<blockquote><p>user.txt
|user_id | name | phone|
|&mdash;&mdash;&ndash;|&mdash;&mdash;|&mdash;&mdash;|
|001     |Alice |123333|
|002     |Bob   |166666|
|&hellip;     |&hellip;   |&hellip;   |</p>

<p>message.txt
|user_id | message|
|&mdash;&mdash;&ndash;|&mdash;&mdash;&ndash;|
|001     |I am Alice|
|002     |I am Bob|
|&hellip;     |&hellip;   |</p></blockquote>

<p>这时候一个用户查看自己发送过的所有的留言。首先做的是从uesr.txt中扫描，找出Alice的user_id信息，然后再在message.txt找出所有的留言。这个过程估计需要你不短的一段代码。跟别提还要各种分割字符串，切出各种字段。还有更难控制的字段的类型，比如日期格式等。</p>

<p>而上面的通用常见的问题，通过数据库系统得到了很好的解决。</p>

<h1>模型层次</h1>

<p>既然说了数据库的目的，那么就来看看怎么构建一个数据库。先看下面的图，描述了数据库的使用层次和实际实现层次。使用层次就是面向用户（程序员），说明系统张什么样子的。而实现层次就是为了支持使用层次而设计的实现方法。使用更专业的术语那就是逻辑层次一个是物理层次。</p>

<p><img src="http://woodcarver.oss-cn-shanghai.aliyuncs.com/post/data_system.png" alt="dddd" /></p>

<p>逻辑层次就是开发者看到的、理解的、认为的样子。对于这层来说大部分数据引擎其实都差不多，不是关系型的就是key-value型。当不了解引擎内部的物理实现逻辑的时候，用户肯定会按照自己理所当然的想法去使用这个系统。这个想法无可厚非，能做到让用户安全放心的使用，尽量屏蔽底层实现也是数据管理系统的追求。不过现在看来当你的数据大一点的时候这个想法有点不现实。</p>

<p>所以如果还不关注其内部实现，就会不断出现红框框的问题，知道你放弃这个系统为止。</p>

<p>但是如果你开始理解其物理层次的机制后，会对逻辑层次有更深入的理解，一些问题也能迎刃而解。</p>

<h1>当谈起一个数据库的时候，我们在说什么？</h1>

<p>两个方面，了解其逻辑模型和物理模型。既然逻辑模型都一样或者差不多，为什么还需要不同的物理模型？原因就没有哪种数据库能支持各种操作到极致的，每种数据库都各种操作都有取舍，各有优缺。有些支持快速的响应，例如redis，有些偏向于？？？？？。</p>

<h2>谈逻辑模型——提供什么服务，支持哪些操作</h2>

<p>两大数据模型 —— 关系型数据模型、key-value数据模型
都支持add、delete、select和update。不过具体支持的方向不同，而不同关键点在<strong>位置</strong>和<strong>范围</strong>的不同。</p>

<ul>
<li>关系型数据模型：基本模型是一个张二维表。

<ul>
<li>add：在表的尾部添加即可。</li>
<li>delete：查找到位置，然后删除。</li>
<li>select：全表扫描，或者利用索引技术。</li>
<li>update：查找到位置，然后更新。</li>
<li>没有递归结构，导致对嵌套数据储存不友好。需要大量的冗余数据。</li>
</ul>
</li>
<li>key-value数据模型

<ul>
<li>add：利用hash funciton后找到其位置，然后添加。</li>
<li>delete：查找到位置，然后删除。</li>
<li>select：利用hash定位。</li>
<li>update：查找到位置，然后更新。</li>
<li>天然的递归结构，对嵌套结构支持友好方便。</li>
</ul>
</li>
</ul>


<p>因为几乎所有的操作都和查找有关，其中查找的效率能直接决定系统的效率。关系型数据库的查找效率(一条数据)要么是O(n)要么是O(logn)，让然也可以是O(1)，以为可以有hash索引。而key-value的查找效率是O(1)。</p>

<h2>谈物理层次——怎么实现这些操作的？如何组合才能最大的发挥其性能？</h2>

<p>物理层次出了决定操作的性能外，还有一个重大的不同，就是对规模扩展的支持程度有巨大的差别。关系型数据库的一个诟病就是对规模扩展非常差。其优良的操作模型和结构化数据要求进一步对大数据量的日志型提出了挑战。</p>

<h2>一个表现的具体问题，<a href="http://stackoverflow.com/questions/1636379/why-db-indexes-use-balanced-trees-not-hashtables">Why DB indexes use balanced trees, not hashtables?</a></h2>

<h2>Has different Characteristics for data operatings</h2>

<p>B-Tree supports comparisons  =, >, >=, &lt;, &lt;=, BETWEEN operators and like, while HashTable only supports =.
so the using scope of HashTable is too narrow.</p>

<h2>HashTable is hard to rescale or grow</h2>

<p>The size of hashtable is determined when it is created. If you add more data than it&rsquo;s size, you need to resize it. And it&rsquo;s very ineffcient. althought there are rescale algorithm or other replication policy(like in redis).</p>

<h2>memory usage effiency</h2>

<p>B+ Tree can be load into memory partially, while HashTable can not. ?? really?</p>

<h2>refernece</h2>

<ol>
<li><a href="https://dev.mysql.com/doc/refman/5.5/en/index-btree-hash.html">Comparison of B-Tree and Hash Indexes</a></li>
</ol>


<h1>reference</h1>

<ul>
<li><a href="https://www.tutorialcup.com/dbms/data-independence.htm">Data Independence</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[java里为什么有了Thread还要设置一个Runnable？]]></title>
    <link href="http://woodcarver.github.io/blog/2016/07/20/why-need-runnable-while-we-already-have-thread-in-java/"/>
    <updated>2016-07-20T21:36:45+08:00</updated>
    <id>http://woodcarver.github.io/blog/2016/07/20/why-need-runnable-while-we-already-have-thread-in-java</id>
    <content type="html"><![CDATA[<p>我学习多线程疑惑，为什么会有这种代码出现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nf">Runnable</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>               <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;this is a runnable&quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">);</span>
</span><span class='line'>    <span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>不是有个更简便的方法吗？</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Thread</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;this is a thread&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">};</span>
</span><span class='line'><span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>虽然很容易知道Runnable是个接口，而Thread是Runnable的一个具体实现。但是既然concurrent包中只有Thread一个类实现，那些Runnable这个接口到底有什么用？
答案就是用户可能会使用到多类继承，但是这在java中是禁止，只能用interface实现。比如我想设计一个任务队列，然后这个任务可以随时开启一个线程运行。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">class</span> <span class="nc">TaskQueue</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">Runnable</span> <span class="o">{</span>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">//...</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据分析利器 —— 列式储存数据库]]></title>
    <link href="http://woodcarver.github.io/blog/2016/07/18/the-world-about-oriental-column-database/"/>
    <updated>2016-07-18T11:00:26+08:00</updated>
    <id>http://woodcarver.github.io/blog/2016/07/18/the-world-about-oriental-column-database</id>
    <content type="html"><![CDATA[<h1><a href="https://en.wikipedia.org/wiki/Column-oriented_database">列式数据库</a></h1>

<p>什么是列式数据库？可能大家也才到了，既然有列式数据库，那么肯定就有行式的喽！确实是这样的。也许大多数人并不了解数据库储存模型（storage model 即physical schema）和数据库的数据模型（data model 也叫 logical schema），不过对上层是使用者也没多大关系。不过我们现在讲的列式和行式就是指数据库的storage model，而他们支持同样的data schema，即对data model感知不到storage model的实现区别。
一个数据库的data model约定可以进行上层数据操作，而storage model决定这些操作的性能。比如，No Sql数据库使用的是data model都是key-value，而储存模型有map结构实现，也可以由tree结构实现。而对于sql数据库，其数据模型是一张二维表，而至于怎么存储这张二维表，很容易就可以想到可以按行存储和按列储存。按行存储就是我们现在常见操作型数据库，而是最大众的数据库，比如MySql、Oracle、……等等你所知道大部分数据库。而按列储存的数据库现在也是很有名，比如Hive、Vertica、Druid、Infobright等。</p>

<h1>为什么要行式数据库又要列式数据库？</h1>

<p>先让让我们想象关于二维表我们有哪些操作？—— select、update、delete和insert。这些操作都会需要找到相应的位置，所以这些操作的基础都是search。
而基本的算法都是即从时间考虑也是从空间考虑的。我们开始具体举个例子。</p>

<p>在数据库储存作为实际的一堆储存在磁盘上的文件，在设计不得不考虑磁盘的特性。一般的磁盘特性，其实所有的储存都有一个特性就是对于locality良好的存取性能是随机存取的好几倍。我们现在把一块想像成一组固定大小的块，如图： disk logic model 而文件的内容实际会被分开按照磁盘逻辑块来储存，数据库主要任务就是怎么组织这些逻辑块来取得更好的读取性能和便捷性。
<img src="../images/posts/disk_block.png" alt="" /></p>

<p>在不考虑索引的情况下，所有的磁盘读取都是顺序读取，这意味了要查找一个东西，都需要扫描全表或者部分表。很直观的道理，读取的性能就是取决于扫描的范围。范围越大，速度当然越慢。
我们先假设我们有一堆如下的数据：</p>

<table>
<thead>
<tr>
<th>RowId</th>
<th>EmpId  </th>
<th>Lastname  </th>
<th>Firstname</th>
<th> Salary</th>
</tr>
</thead>
<tbody>
<tr>
<td>001  </td>
<td>10    </td>
<td>Smith     </td>
<td>Joe     </td>
<td>40000</td>
</tr>
<tr>
<td>002  </td>
<td>12    </td>
<td>Jones     </td>
<td>Mary    </td>
<td>50000</td>
</tr>
<tr>
<td>003  </td>
<td>11    </td>
<td>Johnson   </td>
<td>Cathy   </td>
<td>44000</td>
</tr>
<tr>
<td>004  </td>
<td>22    </td>
<td>Jones     </td>
<td>Bob     </td>
<td>55000</td>
</tr>
</tbody>
</table>


<h2>行式储存模型</h2>

<p>好现在我们开始让磁盘里塞，假设我们的磁盘块只能容下5个字段（抽象的，假设我们的这些字段的大小都一样），因为我们是按找行优先的，所以结果就如下：
<img src="../images/posts/row_oriented.png" alt="row oriented model" /></p>

<p>于是当我们要找Jones的所有信息的工资时候，我们会依次从第一块磁盘块直到扫描到最后（为什么要扫到最后，因为是在找全部叫Jones的信息，所以不扫都最后都不能确定是否会遗漏）。一共需要扫4块，然后取出其第二块和第四块信息，找出其工资的信息。</p>

<p>其实基于行式储存，对于where语句处理都需要处理全表。对于磁盘的不停seek，速度就可想而知。当然一般数据库为了应对这种全数据扫描，找到了建立索引的方法。而索引就是对某个或者某些字段的组合的信息，即取出数据的部分信息，以减少每次扫描从全表到部分信息的扫描的过渡。</p>

<p>这种查询方式很适合于一次取出一个行数据，而对于日常应用系统来说这种方式是非常合适的，因为我们设计应用的时候都是针对一个事务，而我们会把一个事务所有属性存储成一行，使用的时候也是有很大的概率涉及到整行的信息，很利于做缓存。还比如我们经常使用的那些经典sql 语句：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="k">user</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1001</span><span class="p">;</span>
</span><span class='line'><span class="k">select</span> <span class="n">id</span><span class="p">,</span> <span class="n">user_name</span><span class="p">,</span> <span class="n">email</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">gender</span><span class="p">,</span> <span class="p">...</span> <span class="k">from</span> <span class="k">user</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1001</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>！！还敢不敢列出些更多的字段！！</p>

<h2>列式储存模型</h2>

<p>而列储存就是下图这种按列优先储存。为了方便我们每块只储存了一个一列，没有存满。
<img src="../images/posts/column_oriented.png" alt="row oriented model" />
这下我们再考虑上面的查找所有Jones的工资，这下我们只扫描第三个磁盘块，找出Jones都再那些行，然后根据查出来的行号，直接去第五块磁盘（这块对应的式salary列）找出第二、四行的数据，然后输出。一共2次seek。大大小于row－oriented的4次。</p>

<p>这种查询方式的前提就是你就需要这列数据就行了，其前提假设就是查询基本不会使用这个行的其他列数据。显然这种假设对于日常操作系统的围绕着一个主题进行的活动是不合适旳。但是却在分析型数据大显身手。</p>

<p>列式的另一大优势是压缩。因为列的天然凝聚性（比如上面的两个Jones就可以压缩成一个）大大强与行，所以列式储存可以有很高的压缩比，这个进一步使使用的磁盘的数量减少，因为使用的磁盘块少，进一步减少了需要扫描的次数。这方面很利于加快查找速度，但是因为解压缩也是耗时耗内存的过程，所以压缩的控制也是需要一个定平衡点。</p>

<h1>优劣总结</h1>

<p>从上面的例子可以明显看出列式数据库在分析需求（获取特点——每次查询几个维度，通常是）时候，不仅<strong>搜索时间效率</strong>占优势，其<strong>空间效率</strong>也是很明显的。特别是针对动辄按T计算的数据量来说，在分布式环境中能进行压缩处理能节省宝贵的内部带宽，从而提高整个计算任务性能。</p>

<p>关于行式和列式的具体优缺点还有具体的使用场景请看wikipedia。</p>

<h1>再来谈谈储存模型</h1>

<p>从上面看，改变物理储存结构对上层操作效率的提高是如此的巨大！所以我们再深入谈谈这个话题。</p>

<p>在数据模型一定的情况下，储存模型也是有多种选择的（想想各种不同数据结构居然提供同样的操作，比如TreeMap和HashMap。数据模型好比Map支持getKey和getValue。而储存模型就是Tree还是HashTable，而getKey和getValue操作虽然对使用者没有区别，但是底层的组织结构则决定了其效率）。而储存模型在数据库这种复杂系统中有分好多层。我们想想先从最底层说起——文件，数据终归都是储存在磁盘上的。而从下面的表格看出，数据要取出必须先进入到内存，那么这个层次的核心就是面对各种查询、写入、更新和删除，怎么快速把数据从磁盘加载到内存中或者反之怎么把数据从内存中快速的写入到磁盘中。</p>

<table>
<thead>
<tr>
<th>用户界面</th>
</tr>
</thead>
<tbody>
<tr>
<td>内存    </td>
</tr>
<tr>
<td>磁盘    </td>
</tr>
</tbody>
</table>


<p>所以先谈谈文件储存有哪些类型：<a href="https://www.tutorialcup.com/dbms/file-organization.htm">File Organization in DBMS</a> 这篇文章对于文件组织在DBMS中的意义讲的非常清楚。这里引出其中对文件组织的要点：</p>

<blockquote><p>Storing the files in certain order is called file organization. The main objective of file organization is</p>

<ul>
<li>Optimal selection of records i.e.; records should be accessed as fast as possible. &ndash; 支持快速的获取</li>
<li>Any insert, update or delete transaction on records should be easy, quick and should not harm other records. &ndash; 支持快读的插入、更新和删除事务</li>
<li>No duplicate records should be induced as a result of insert, update or delete &ndash; 支持键值不重复？？？</li>
<li>Records should be stored efficiently so that cost of storage is minimal. &ndash; 储存占用磁盘空间要小</li>
</ul>
</blockquote>

<p>从上面的目的看，大多数不能同时满足，这样就出现了各种各样的组合选择，所以出现多种组织方式：</p>

<ul>
<li>Sequential File Organization</li>
<li>Heap File Organization</li>
<li>Hash/Direct File Organization</li>
<li>Indexed Sequential Access Method</li>
<li>B+ Tree File Organization</li>
<li>Cluster File Organization
Let us see one by one on clicking the above links</li>
</ul>


<p>Difference between Sequential, heap/Direct, Hash, ISAM, B+ Tree, Cluster file organization in database management system (DBMS) as shown below:</p>

<table>
<thead>
<tr>
<th>          </th>
<th>Sequential</th>
<th> Heap/Direct</th>
<th>Hash </th>
<th>ISAM </th>
<th>B+ tree</th>
<th>Cluster</th>
</tr>
</thead>
<tbody>
<tr>
<td>Method of storing </td>
<td>Stored as they come or sorted as they come </td>
<td>Stored at the end of the file. But the address in the memory is random. </td>
<td>Stored at the hash address generated</td>
<td>Address index is appended to the record </td>
<td>Stored in a tree like structure </td>
<td>Frequently joined tables are clubbed into one file based on cluster key</td>
</tr>
<tr>
<td>疑问</td>
<td>如何做到删除的？</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Types </td>
<td>Pile file and sorted file Method </td>
<td> </td>
<td>Static and dynamic hashing </td>
<td> Dense, Sparse, multilevel </td>
<td>indexing </td>
<td>Indexed and Hash</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Design</td>
<td>Simple Design</td>
<td>Simplest</td>
<td>Medium</td>
<td>Complex</td>
<td>Complex</td>
<td>Simple</td>
</tr>
<tr>
<td>Storage Cost</td>
<td>Cheap (magnetic tapes)</td>
<td>Cheap</td>
<td>Medium</td>
<td>Costlier</td>
<td>Costlier</td>
<td>Medium</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Advantage </td>
<td>Fast and efficient when there is large volumes of data, Report generation, statistical calculations etc</td>
<td>  Best suited for bulk insertion, and small files/tables</td>
<td>Faster Access,No Need to Sort,Handles multiple transactions,Suitable for Online transactions</td>
<td> Searching records is faster.Suitable for large database.Any of the columns can be used as key column.Searching range of data &amp; partial data are efficient.</td>
<td> Searching range of data &amp; partial data are efficient.No performance degrades when there is insert / delete / update.Grows and shrinks with data.Works well in secondary storage devices and hence reducing disk I/O.Since all datas are at the leaf node, searching is easy.All data at leaf node are sorted sequential linked list.</td>
<td>Best suited for frequently joined tables.Suitable for 1:M mappings</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Disadvantage </td>
<td>Sorting of data each time for insert/delete/ update takes time and makes system slow.  </td>
<td>Records are scattered in the memory and they are inefficiently used. Hence increases the memory size.  Proper memory management is needed.  Not suitable for large tables. </td>
<td>Accidental Deletion or updation of Data. Use of Memory is inefficient Searching range of data, partial data, non-hash key column, searching single hash column when multiple hash keys present or frequently updated column as hash key are inefficient. </td>
<td>Extra cost to maintain index. File reconstruction is needed as insert/update/delete.Does not grow with data.  </td>
<td>Not suitable for static tables  </td>
<td>Not suitable for large database. Suitable only for the joins on which clustering is done. Less frequently used joins and 1: 1 Mapping are inefficient.</td>
</tr>
</tbody>
</table>


<h1>refernce</h1>

<ul>
<li><a href="https://www.tutorialcup.com/dbms/file-organization.htm">File Organization in DBMS</a></li>
<li><a href="https://en.wikipedia.org/wiki/Database_storage_structures">Database storage structures</a></li>
<li><a href="http://blog.csdn.net/cjfeii/article/details/8884658">关系型数据在磁盘上的存储布局</a></li>
<li><a href="http://blog.csdn.net/v_july_v/article/details/7526689">从LSM-Tree、COLA-Tree谈到StackOverflow、OSQA</a></li>
<li><a href="http://www.cnblogs.com/siegfang/archive/2013/01/12/lsm-tree.html">日志结构的合并树 The Log-Structured Merge-Tree</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Develop Your Own Jdbc Application]]></title>
    <link href="http://woodcarver.github.io/blog/2016/07/18/how-to-develop-your-own-jdbc-application/"/>
    <updated>2016-07-18T10:54:05+08:00</updated>
    <id>http://woodcarver.github.io/blog/2016/07/18/how-to-develop-your-own-jdbc-application</id>
    <content type="html"><![CDATA[<p>刚接触java的小朋友们是不是都发现jdbc这个东西挺好用？所有的数据引擎都完全一致的采用jdbc来连接，这种一致性简直太爽了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Producer-consumer Problem]]></title>
    <link href="http://woodcarver.github.io/blog/2016/07/15/producer-consumer-problem/"/>
    <updated>2016-07-15T23:55:14+08:00</updated>
    <id>http://woodcarver.github.io/blog/2016/07/15/producer-consumer-problem</id>
    <content type="html"><![CDATA[<p>最近在学习多线程编程，周末的时候用java写了一个生产者消费模型，这里做一些记录和总结。</p>

<h2>基本模板</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Producer
</span><span class='line'>  while(true)
</span><span class='line'>    data = generateData()
</span><span class='line'>    queue.enqueue(data)
</span><span class='line'>
</span><span class='line'>Consumer
</span><span class='line'>  while(true)
</span><span class='line'>    data = queue.dequeue()
</span><span class='line'>
</span><span class='line'>main
</span><span class='line'>  sharedQueue = new Queue()
</span><span class='line'>  producer1, producer2 ...
</span><span class='line'>  consumer1, consumer2 ...
</span><span class='line'>  start producer1, producer2 ...
</span><span class='line'>  start consumer1, consumer2 ...
</span><span class='line'>  stop producer1, producer2 ...
</span><span class='line'>  stop consumer1, consumer2 ...</span></code></pre></td></tr></table></div></figure>


<h2>各种错误版</h2>

<h3>最简单版</h3>

<p>这个程序中工作任务很简单就是生产者不断放入一些随机数到队列中，而消费者就是不断取出这些数并打印。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProducerConsumer</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">static</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
</span><span class='line'>
</span><span class='line'>      <span class="kt">int</span> <span class="n">producerNum</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>      <span class="n">Producer</span><span class="o">[]</span> <span class="n">producers</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Producer</span><span class="o">[</span><span class="n">producerNum</span><span class="o">];</span>
</span><span class='line'>      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">producerNum</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">producers</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Producer</span><span class="o">(</span><span class="n">queue</span><span class="o">);</span>
</span><span class='line'>          <span class="n">producers</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">start</span><span class="o">();</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>      <span class="kt">int</span> <span class="n">consumerNum</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
</span><span class='line'>      <span class="n">Consumer</span><span class="o">[]</span> <span class="n">consumers</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Consumer</span><span class="o">[</span><span class="n">consumerNum</span><span class="o">];</span>
</span><span class='line'>      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">consumerNum</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">consumers</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Consumer</span><span class="o">(</span><span class="n">queue</span><span class="o">);</span>
</span><span class='line'>          <span class="n">consumers</span><span class="o">[</span><span class="n">j</span><span class="o">].</span><span class="na">start</span><span class="o">();</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">1000</span><span class="o">);</span>
</span><span class='line'>          <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Main thread is awaken now!&quot;</span><span class="o">);</span>
</span><span class='line'>      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="c1">// TODO Auto-generated catch block</span>
</span><span class='line'>          <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      <span class="c1">// stopping all producers and consumers</span>
</span><span class='line'>      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">producerNum</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">producers</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">stopLoop</span><span class="o">();</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">consumerNum</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">consumers</span><span class="o">[</span><span class="n">j</span><span class="o">].</span><span class="na">stopLoop</span><span class="o">();</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      <span class="c1">// make sure all threads are stopped</span>
</span><span class='line'>      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">producerNum</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>              <span class="n">producers</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">join</span><span class="o">();</span>
</span><span class='line'>              <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Producer: &quot;</span> <span class="o">+</span> <span class="n">producers</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">getId</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot; is stopped!&quot;</span><span class="o">);</span>
</span><span class='line'>          <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>              <span class="c1">// TODO Auto-generated catch block</span>
</span><span class='line'>              <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">consumerNum</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>              <span class="n">consumers</span><span class="o">[</span><span class="n">j</span><span class="o">].</span><span class="na">join</span><span class="o">();</span>
</span><span class='line'>              <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Consumer: &quot;</span> <span class="o">+</span> <span class="n">consumers</span><span class="o">[</span><span class="n">j</span><span class="o">].</span><span class="na">getId</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot; is stopped!&quot;</span><span class="o">);</span>
</span><span class='line'>          <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>              <span class="c1">// TODO Auto-generated catch block</span>
</span><span class='line'>              <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">class</span> <span class="nc">Producer</span> <span class="kd">extends</span> <span class="n">Thread</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">private</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">running</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">long</span> <span class="n">threadId</span><span class="o">;</span> <span class="c1">// 因为每次run之后，才会进入到新的thread</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">static</span> <span class="n">Lock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ReentrantLock</span><span class="o">();</span>
</span><span class='line'>  <span class="kd">public</span> <span class="nf">Producer</span><span class="o">(</span><span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">queue</span> <span class="o">=</span> <span class="n">queue</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="nd">@Override</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">threadId</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getId</span><span class="o">();</span>
</span><span class='line'>      <span class="k">while</span> <span class="o">(</span><span class="n">running</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>              <span class="kt">double</span> <span class="n">item</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">random</span><span class="o">()</span> <span class="o">*</span> <span class="mi">100</span><span class="o">;</span>
</span><span class='line'>              <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span> <span class="c1">// 这里为什么加锁？因为queue我们使用的是LinkedList，所以offer操作不是同步的，不能让不同的生产者互相争抢</span>
</span><span class='line'>              <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">((</span><span class="kt">int</span><span class="o">)</span><span class="n">item</span><span class="o">);</span>
</span><span class='line'>              <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Produce:&quot;</span> <span class="o">+</span> <span class="n">threadId</span> <span class="o">+</span> <span class="s">&quot;--&quot;</span> <span class="o">+</span> <span class="n">item</span><span class="o">);</span>
</span><span class='line'>          <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>              <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span><span class='line'>          <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span><span class='line'>              <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span> <span class="c1">// 放在finally中，保证程序不会中途出错而导致解锁步骤不运行</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">stopLoop</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Stopping Producer -- &quot;</span> <span class="o">+</span> <span class="n">threadId</span><span class="o">);</span>
</span><span class='line'>      <span class="n">running</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="kd">class</span> <span class="nc">Consumer</span> <span class="kd">extends</span> <span class="n">Thread</span> <span class="o">{</span>
</span><span class='line'>  <span class="cm">/**</span>
</span><span class='line'><span class="cm">  * 这版开始加锁，不再出现NullPointerException错误</span>
</span><span class='line'><span class="cm">  * 消费的过程中其实和生产的过程没有冲突，所以只要消费者之间共享一把锁就行了</span>
</span><span class='line'><span class="cm">  * 让queue.peek 和 poll绑定，使之检查是有效的</span>
</span><span class='line'><span class="cm">  */</span>
</span><span class='line'>  <span class="kd">private</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">running</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">static</span> <span class="n">Lock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ReentrantLock</span><span class="o">();</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">long</span> <span class="n">threadId</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">public</span> <span class="nf">Consumer</span><span class="o">(</span><span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">queue</span> <span class="o">=</span> <span class="n">queue</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="nd">@Override</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">threadId</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getId</span><span class="o">();</span>
</span><span class='line'>      <span class="k">while</span> <span class="o">(</span><span class="n">running</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>                  <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span> <span class="c1">// 加锁第一是因为poll非同步，还有peek和poll之间非原子性，不加锁会导致peek检查很容易失效</span>
</span><span class='line'>                      <span class="k">if</span> <span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// double check</span>
</span><span class='line'>                          <span class="kt">int</span> <span class="n">item</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
</span><span class='line'>                          <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Consume:&quot;</span> <span class="o">+</span> <span class="n">threadId</span> <span class="o">+</span><span class="s">&quot; -- &quot;</span> <span class="o">+</span> <span class="n">item</span><span class="o">);</span>
</span><span class='line'>                      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>                          <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Consume:&quot;</span> <span class="o">+</span> <span class="n">threadId</span> <span class="o">+</span><span class="s">&quot; -- empty&quot;</span><span class="o">);</span>
</span><span class='line'>                      <span class="o">}</span>
</span><span class='line'>          <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span><span class='line'>          <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">stopLoop</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Stopping Consumer: &quot;</span> <span class="o">+</span> <span class="n">threadId</span><span class="o">);</span>
</span><span class='line'>      <span class="n">running</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>开始点评这个版本：
- 巨大的缺点就是queue是无界的，很容易造成queue被爆掉
- running这个变量非同步，所以在主线程中调用stopLoop虽然可能生效，但是按照java的内存模型来说，没有同步的变量在不同线程中可能不能被互相观察到，这导致consumer的线程都观察不到running已经被主线程设置为false了。从而导致程序停不下来（查看<a href="https://www.amazon.cn/Sun-%E5%85%AC%E5%8F%B8%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6-Effective-Java%E4%B8%AD%E6%96%87%E7%89%88-Joshua-Bloch/dp/B001PTGR52/ref=sr_1_1?ie=UTF8&amp;qid=1468729174&amp;sr=8-1&amp;keywords=effective+java">Effective java的66条</a>）。解决这个问题有两种方法，一种是使用synchronized修饰的方法来封装running的读写，一种是把running秀事成volatile（参看<a href="https://www.amazon.cn/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E5%91%A8%E5%BF%97%E6%98%8E/dp/B00D2ID4PK/ref=sr_1_1?ie=UTF8&amp;qid=1468728884&amp;sr=8-1&amp;keywords=jvm">深入理解Java虚拟机:JVM高级特性与最佳实践</a>）。</p>

<h3>queue实现有界版</h3>

<p>自己利用LinkedList实现了一个BlockQueue，当然java中本身就有个这个而数据结构，这个造轮子只是为了理解其中的原理。
这次这个程序稍微复杂一些，存取的不在是随机数，而是一个个log。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * 1、第一版的时候我们只用了linkedlist来模拟queu，但是让出现producer特别慢，但是consumer又总是再探测浪费资源？</span>
</span><span class='line'><span class="cm"> * 2、还有就是producer产生速度过去快，难道就让它把内存挤爆吗？</span>
</span><span class='line'><span class="cm"> * 3、所以我们需要blockingQueue，第一是限制queue的大小，第二是协调两方的生产和消费速度。</span>
</span><span class='line'><span class="cm"> * @author xiedandan</span>
</span><span class='line'><span class="cm"> *</span>
</span><span class='line'><span class="cm"> * 疑问点：使用monitor来设计一个blocking Queue</span>
</span><span class='line'><span class="cm"> * 1. 不对queue进行synchronize，会爆出IllegalMonitorException</span>
</span><span class='line'><span class="cm"> * 2. 然后开始不断调整synchronize位置，比如在while(running)外边，在while(running)里面</span>
</span><span class='line'><span class="cm"> * 3. 然后就开了怎么都唤不醒consumer的bug</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProducerConsumerBlockingQueue</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">static</span> <span class="n">SudoBlockingQueue</span><span class="o">&lt;</span><span class="n">Log</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="c1">// 和格版本一致</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="cm">/* mimic a bin-log restore system.</span>
</span><span class='line'><span class="cm"> * Producer to produce operating logs and consumer to read the logs and try to restore the record.</span>
</span><span class='line'><span class="cm"> * log schema: transactionId, operatingType, dataValue(before current operation)</span>
</span><span class='line'><span class="cm"> *</span>
</span><span class='line'><span class="cm"> * version 1: Suppose we only have one row record in whole table and only add operation,</span>
</span><span class='line'><span class="cm"> *             so the log order is not important.</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kd">class</span> <span class="nc">ProducerLog</span> <span class="kd">extends</span> <span class="n">Thread</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">private</span> <span class="n">SudoBlockingQueue</span><span class="o">&lt;</span><span class="n">Log</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">boolean</span> <span class="kd">volatile</span> <span class="n">running</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">long</span> <span class="n">threadId</span><span class="o">;</span>
</span><span class='line'>  <span class="c1">// private Lock lock; // 1. 为啥在这里我们不用lock呢？因为都封装在queue自身中了。</span>
</span><span class='line'>  <span class="kd">public</span> <span class="nf">ProducerLog</span><span class="o">(</span><span class="n">SudoBlockingQueue</span><span class="o">&lt;</span><span class="n">Log</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">queue</span> <span class="o">=</span> <span class="n">queue</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="nd">@Override</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">threadId</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getId</span><span class="o">();</span>
</span><span class='line'>      <span class="k">while</span><span class="o">(</span><span class="n">running</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>              <span class="kd">synchronized</span><span class="o">(</span><span class="n">queue</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 2. 试试把这句话取掉会产生结果？</span>
</span><span class='line'>      <span class="c1">//         1.if (queue.isFull()) { // 3. 为什么不能使用if，而要使用while？</span>
</span><span class='line'>                  <span class="k">while</span> <span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">isFull</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>                      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Proudce:&quot;</span> <span class="o">+</span> <span class="n">threadId</span> <span class="o">+</span> <span class="s">&quot;--- wait&quot;</span><span class="o">);</span>
</span><span class='line'>                      <span class="n">queue</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
</span><span class='line'>                  <span class="o">}</span>
</span><span class='line'>                  <span class="kt">boolean</span> <span class="n">e</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>
</span><span class='line'>                  <span class="n">Log</span> <span class="n">log</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Log</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="n">Math</span><span class="o">.</span><span class="na">random</span><span class="o">()</span> <span class="o">*</span> <span class="mi">100</span><span class="o">));</span>
</span><span class='line'>                  <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Proudce:&quot;</span> <span class="o">+</span> <span class="n">threadId</span> <span class="o">+</span> <span class="s">&quot;---&quot;</span> <span class="o">+</span> <span class="n">log</span><span class="o">);</span>
</span><span class='line'>                  <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">log</span><span class="o">);</span>
</span><span class='line'>                  <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Proudce:&quot;</span> <span class="o">+</span> <span class="n">threadId</span> <span class="o">+</span> <span class="s">&quot;--- notify all&quot;</span><span class="o">);</span>
</span><span class='line'>                      <span class="n">queue</span><span class="o">.</span><span class="na">notifyAll</span><span class="o">();</span>
</span><span class='line'>                  <span class="o">}</span>
</span><span class='line'>              <span class="o">}</span>
</span><span class='line'>          <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>              <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">stopLoop</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Stopping Prouder:&quot;</span> <span class="o">+</span> <span class="n">threadId</span><span class="o">);</span>
</span><span class='line'>      <span class="n">running</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>      <span class="n">queue</span><span class="o">.</span><span class="na">syncNotifyAll</span><span class="o">();</span> <span class="c1">// 4. 为啥这里还有再次notifyall一次呢？</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="kd">class</span> <span class="nc">ConsumerLog</span> <span class="kd">extends</span> <span class="n">Thread</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">private</span> <span class="n">SudoBlockingQueue</span><span class="o">&lt;</span><span class="n">Log</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">running</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">long</span> <span class="n">threadId</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">public</span> <span class="nf">ConsumerLog</span><span class="o">(</span><span class="n">SudoBlockingQueue</span><span class="o">&lt;</span><span class="n">Log</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">queue</span> <span class="o">=</span> <span class="n">queue</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="nd">@Override</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">threadId</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getId</span><span class="o">();</span>
</span><span class='line'>      <span class="k">while</span><span class="o">(</span><span class="n">running</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>              <span class="kd">synchronized</span><span class="o">(</span><span class="n">queue</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                  <span class="k">while</span> <span class="o">(</span><span class="n">running</span> <span class="o">&amp;&amp;</span> <span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>                      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Consumer:&quot;</span> <span class="o">+</span> <span class="n">threadId</span> <span class="o">+</span> <span class="s">&quot;--wait&quot;</span><span class="o">);</span>
</span><span class='line'>                      <span class="n">queue</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
</span><span class='line'>                  <span class="o">}</span>
</span><span class='line'>                  <span class="kt">boolean</span> <span class="n">f</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">isFull</span><span class="o">();</span>
</span><span class='line'>                  <span class="n">Log</span> <span class="n">log</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
</span><span class='line'>                  <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Consumer:&quot;</span> <span class="o">+</span> <span class="n">threadId</span> <span class="o">+</span> <span class="s">&quot;--&quot;</span> <span class="o">+</span> <span class="n">log</span><span class="o">);</span>
</span><span class='line'>                  <span class="k">if</span> <span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Consumer:&quot;</span> <span class="o">+</span> <span class="n">threadId</span> <span class="o">+</span> <span class="s">&quot;--notify&quot;</span><span class="o">);</span>
</span><span class='line'>                      <span class="n">queue</span><span class="o">.</span><span class="na">notifyAll</span><span class="o">();</span>
</span><span class='line'>                  <span class="o">}</span>
</span><span class='line'>              <span class="o">}</span>
</span><span class='line'>          <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>              <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">stopLoop</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Stopping Consumer -- &quot;</span> <span class="o">+</span> <span class="n">threadId</span><span class="o">);</span>
</span><span class='line'>      <span class="n">running</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>      <span class="n">queue</span><span class="o">.</span><span class="na">syncNotifyAll</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="kd">class</span> <span class="nc">Log</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">int</span> <span class="n">tranId</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">int</span> <span class="n">operaType</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">int</span> <span class="n">data</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">public</span> <span class="nf">Log</span><span class="o">(</span><span class="kt">int</span> <span class="n">tranId</span><span class="o">,</span> <span class="kt">int</span> <span class="n">operaType</span><span class="o">,</span> <span class="kt">int</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">tranId</span> <span class="o">=</span> <span class="n">tranId</span><span class="o">;</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">operaType</span> <span class="o">=</span> <span class="n">operaType</span><span class="o">;</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="nd">@Override</span>
</span><span class='line'>  <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="s">&quot;TranId:&quot;</span> <span class="o">+</span> <span class="n">tranId</span> <span class="o">+</span> <span class="s">&quot;,OperaType:&quot;</span> <span class="o">+</span> <span class="n">operaType</span> <span class="o">+</span> <span class="s">&quot;,Data&quot;</span> <span class="o">+</span> <span class="n">data</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="kd">class</span> <span class="nc">SudoBlockingQueue</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="mi">13344L</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">CAPACITY</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">public</span> <span class="nf">SudoBlockingQueue</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">CAPACITY</span> <span class="o">=</span> <span class="n">capacity</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="kt">boolean</span> <span class="nf">isFull</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="n">CAPACITY</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="kt">int</span> <span class="nf">getCapacity</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">CAPACITY</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">syncNotifyAll</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">notifyAll</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">syncWait</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">this</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
</span><span class='line'>      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="c1">// TODO Auto-generated catch block</span>
</span><span class='line'>          <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>回答上面的问题：</p>

<ol>
<li>为什么要对queue进行同步呢？原因之一是是前一个例子一样lock的作用，同步offer的。还有一个重要的原因是queue.wait()和queue.notify()必须在拥有当前queue的控制权时候才能进行。不然会报IllegalMonitorStateException(关于为什么会产生这个异常，参看<a href="http://www.cnblogs.com/techyc/p/3272321.html">Java的wait(), notify()和notifyAll()使用小结</a>)。</li>
<li>为什么不能使用if，而要使用while？原因是为了double check，想想有3个消费者，其生产的消费速度远远大于生产速度。当一个任务被生产出来，唤醒了全部的consumers，这时候多个consumer准备结束queue.wait()。但是只有一个consumer能抢到资源，其他的consumer如果不再次做isEmpty检查就会误以为任务，继续走下去，结果发生错误。一定参看这篇文章：<a href="http://www.importnew.com/16453.html">如何在 Java 中正确使用 wait, notify 和 notifyAll – 以生产者消费者模型为例</a></li>
<li>为啥这里还有再次notifyAll一次呢？因为当stop的时候有些线程正处于wait装填，必须唤醒才能从while(running)跳出来。因为notifyAll需要保证获得queue的控制权，所以需要synchronized。</li>
</ol>


<p>这个版本设计的也比较糟糕，因为需要调用多次的stopLoop，可以把running设计成static，只用调用一次stopLoop即可。</p>

<h2>关于 wait(), notify() and notifyAll()的一些理解</h2>

<ul>
<li>这些是都是一个Monitor同步模型的一些具体操作。<a href="http://www.javamadesoeasy.com/2015/03/why-wait-notify-and-notifyall-are-in.html">下面引用这篇文章</a></li>
<li>Every Object has a monitor, acquiring that monitors allow thread to hold lock on object. But Thread class does not have any monitors.</li>
<li><p>wait(), notify() and notifyAll() are called on objects only > When wait() method is called on object by thread it waits for another thread on that object to release object monitor by calling notify() or notifyAll() method on that object.
When notify() method is called on object by thread it notifies all the threads which are waiting for that object monitor that object monitor is available now.
So, this shows that wait(), notify() and notifyAll() are called on objects only.
Now, Straight forward question that comes to mind is how thread acquires object lock by acquiring object monitor? Let’s try to understand this basic concept in detail?</p></li>
<li><p>Wait(), notify() and notifyAll() method being in Object class allows all the threads created on that object to communicate with other.  [As multiple threads may exist on same object].</p></li>
<li><p>As multiple threads exists on same object. Only one thread can hold object monitor at a time. As a result thread can notify other threads of same object that lock is available now. But, thread having these methods does not make any sense because multiple threads exists on object it&rsquo;s not other way around (i.e. multiple objects exists on thread).</p></li>
<li><p>Now let’s discuss one hypothetical scenario, what will happen if Thread class contains wait(), notify() and notifyAll() methods?
Having wait(), notify() and notifyAll() methods means Thread class also must have their monitor.
Every thread having their monitor will create few problems -</p>

<blockquote><p>Thread communication problem.
Synchronization on object won’t be possible- Because object has monitor, one object can have multiple threads and thread hold lock on object by holding object monitor. But if each thread will have monitor, we won’t have any way of achieving synchronization.
Inconsistency in state of object (because synchronization won&rsquo;t be possible).</p></blockquote></li>
</ul>


<h2>写正确一个并发程序真实不容易，特别容易遇到各种死锁而结束不了程序。学会并发编程：</h2>

<ol>
<li><a href="./">生产者消费模型</a></li>
<li><a href="./">线程池</a></li>
<li><a href="./">进程池</a></li>
<li><a href="./">LRU缓存</a></li>
</ol>


<h3>refenrence</h3>

<ul>
<li><a href="http://www.importnew.com/10173.html">notify和notifyAll的一段代码分析</a></li>
<li><a href="http://stackoverflow.com/questions/20110013/implement-your-own-blocking-queue-in-java">implement-your-own blocking queue in java</a></li>
<li><a href="http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/locks/Condition.html">Interface Condition</a></li>
<li><a href="http://www.importnew.com/16453.html">如何在 Java 中正确使用 wait, notify 和 notifyAll – 以生产者消费者模型为例</a></li>
<li><a href="http://www.cnblogs.com/techyc/p/3272321.html">Java的wait(), notify()和notifyAll()使用小结</a></li>
<li><a href="http://www.ticmy.com/?p=219"></a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why Many Data Structrues Have Logn Relative Time Complexity]]></title>
    <link href="http://woodcarver.github.io/blog/2016/07/07/why-many-data-structrues-have-logn-relative-time-complexity/"/>
    <updated>2016-07-07T21:50:55+08:00</updated>
    <id>http://woodcarver.github.io/blog/2016/07/07/why-many-data-structrues-have-logn-relative-time-complexity</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduce Redis]]></title>
    <link href="http://woodcarver.github.io/blog/2016/07/07/introduce-redis/"/>
    <updated>2016-07-07T21:35:59+08:00</updated>
    <id>http://woodcarver.github.io/blog/2016/07/07/introduce-redis</id>
    <content type="html"><![CDATA[<p>观点一：redis采用结构化数据，打通了代码和储存
关键技术： event loop， single thread</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Desgin a Thread Pool]]></title>
    <link href="http://woodcarver.github.io/blog/2016/06/22/how-to-desgin-a-thread-pool/"/>
    <updated>2016-06-22T23:11:22+08:00</updated>
    <id>http://woodcarver.github.io/blog/2016/06/22/how-to-desgin-a-thread-pool</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why Connection Need 3-way Handshake While Disconnection Need 4-way in Tcp?]]></title>
    <link href="http://woodcarver.github.io/blog/2016/05/30/why-connection-need-3-way-handshake-while-disconnection-need-4-way-in-tcp/"/>
    <updated>2016-05-30T11:30:53+08:00</updated>
    <id>http://woodcarver.github.io/blog/2016/05/30/why-connection-need-3-way-handshake-while-disconnection-need-4-way-in-tcp</id>
    <content type="html"><![CDATA[<h1>reference</h1>

<ul>
<li><a href="http://baike.baidu.com/link?url=8_DsYi4pjWpNRFrSX10jiGxe0PLruypbRhv4o56eXOi07tQPokeFgnt1_leXVDy7ELc-uR4_E1cr1NfV3lJUYK">http://baike.baidu.com/link?url=8_DsYi4pjWpNRFrSX10jiGxe0PLruypbRhv4o56eXOi07tQPokeFgnt1_leXVDy7ELc-uR4_E1cr1NfV3lJUYK</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[操作系统中的各种尝试参数]]></title>
    <link href="http://woodcarver.github.io/blog/2016/05/14/important-number-in-software-system-designing/"/>
    <updated>2016-05-14T17:48:06+08:00</updated>
    <id>http://woodcarver.github.io/blog/2016/05/14/important-number-in-software-system-designing</id>
    <content type="html"><![CDATA[<h1>各种储存设备的速度量级</h1>

<p>时间单位是cpu cycles。
| 储存类型    | 缓存的内容 | 储存的媒介| 处理速度| 被谁管理
|&mdash;&mdash;&mdash;&mdash;-|&mdash;&mdash;&mdash;&mdash;|&mdash;&mdash;&mdash;&ndash;|&mdash;&mdash;&mdash;|&mdash;&mdash;&mdash;
|cpu register| 4~8 byte word | 寄存器| 0| 编译器
|TLB | Address translations| On-chip TLB| 0| Hardware MMU
|L1 cache | 64-byte block| On-chip L1 cache| 1| Hardware
|L2 cache | 64-byte block| On-chip L2 cache| 10| Hardware
|L3 cache | 64-byte block| On-chip L3 cache| 30| Hardware
|Virtual memory| 4-KB page| main memory| 100| Hardware + OS
|Buffer cache| Parts of files| main memory| 100| OS
|Disk cache| Disk sectors| Disk controller| 100,00| Controller firmware
|Network cache| Parts of files| Local disk| 10,000,000| AFS/NFS client
|Browser cache| Web pages| Local disk| 10,000,000| Web browser
|Web cache    | Web pages| Remote server disks| 1,000,000,000| Web proxy server</p>

<p>从上面看到，内存的访问速度是磁盘的1万倍（不过也要看是什么磁盘，比如固态磁盘访问速度是）
固态磁盘(ssd)的读写速度：
读            |写
&mdash;&mdash;&mdash;&mdash;&ndash;|&mdash;-
顺序：250MB/s |顺序：170MB/s
随机：140MB/s |顺序：14MB/s
固态磁盘(ssd)的读写速度大概是普通磁盘的10倍。</p>

<h1>reference</h1>

<ul>
<li><a href="http://www.directionsmag.com/entry/ram-is-100-thousand-times-faster-than-disk-for-database-access/123964">ram-is-100-thousand-times-faster disk</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Algorithms Summary]]></title>
    <link href="http://woodcarver.github.io/blog/2016/04/28/algorithms-summary/"/>
    <updated>2016-04-28T10:53:35+08:00</updated>
    <id>http://woodcarver.github.io/blog/2016/04/28/algorithms-summary</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduce MapReduce]]></title>
    <link href="http://woodcarver.github.io/blog/2016/04/24/introduce-mapreduce/"/>
    <updated>2016-04-24T19:16:20+08:00</updated>
    <id>http://woodcarver.github.io/blog/2016/04/24/introduce-mapreduce</id>
    <content type="html"><![CDATA[<h1>mapreduce 的各个阶段解释</h1>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Manage Your Work]]></title>
    <link href="http://woodcarver.github.io/blog/2016/04/23/how-to-manage-your-work/"/>
    <updated>2016-04-23T12:06:20+08:00</updated>
    <id>http://woodcarver.github.io/blog/2016/04/23/how-to-manage-your-work</id>
    <content type="html"><![CDATA[<h1>如何管理自己的项目</h1>

<p>不管你是Leader or not，都会牵涉到管理自己的项目问题，只是角色不一样而已。我模仿下《布道之道》的结构总结一些模式，然后在分析怎么用这些模式（或者是原则）。如何又快又好的最大化自己的工作成效呢？It&rsquo;s a question.</p>

<h2>关键点</h2>

<ol>
<li>项目跟踪</li>
<li>实时有效反馈</li>
<li>项目预判和重要级划分，时效性估计，特别是针对所谓的紧急任务</li>
<li>树立合作处理模式和规则，让合作的人可以预测</li>
<li>项目总结</li>
</ol>


<h1>如何处理一个紧急事务</h1>

<h2>事中处理</h2>

<p>可能作为一线员工，接到紧急任务的最常用方法就是，放下手中的工作然后转向紧急任务处理，因为选择安排任务的空间比较小。
而我们都知道插入任务，必定会导致已有的任务延迟或者将来规划的任务延期。而延期的多长时间就要依赖于处理插入事务的速度了。而唯一能加快处理速度的方法就是以前积累类似case的处理经验。
所以就要用到P5，一定要注意总结。</p>

<h2>事前预防</h2>

<p>这个地方可以采取的措施就很多了。
第一点就是要弄清楚为什么要做这个任务，如果对公司的业务做够熟悉（这个需要公司业务积累），那么很容易判断出来这个任务到底有没有意义或者有更优化的解决方案，或者根本就不用做了。
第二点是弄清楚自己能不能接，如果不能接（比如自己有更重要的事情要完成），建议交给别人或者让拒绝对方的无理要求。
第三点是树立自己的处理事务模式(P4)，让需求方提出需求前有个预测他们的任务会不会被自己拒绝。
第四点就是分析经历过的项目(P5)，找出模式，做好事先准备。
第五点，如果公司有很好的反馈机制，知道其他和自己相关的项目正在进行，但是还没有进行到自己这里，这里就需要使用P1，预判什么时候到自己这里，可以做事前准备。再着前置任务延迟，提醒他们延迟的后果，再一定程度上提醒前置任务的速度。</p>

<h2>事后总结</h2>

<p>任务完了，还有很多事要做，才能保证将来的工作成效能提升：
第一点：还是P5， 这里有业务方向和技术方向两大块。业务方向出来事情的意义还有事情产生的时间模式。</p>

<h1>如何判断一个项目，你能不能接</h1>

<p>当一下子来一个大项目，其实一下子估计自己什么时候完成是一个很大的挑战。
所以采取的方案就是，项目拆分。只有当项目足够小，才能被看清、预估，才能被很好的执行 —— 分冶的思想。</p>

<h1>reference</h1>

<ul>
<li><a href="https://www.livecoding.tv/udm/videos/xYvyp-1dv600-l03-planning-and-managing-projects">planning and managing pojects</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
