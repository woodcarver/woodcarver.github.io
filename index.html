
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Wood Carver</title>
  <meta name="author" content="Wood Carver">

  
  <meta name="description" content="ctr模型预估 Logistic Regression
">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://woodcarver.github.io/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Wood Carver" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/libs/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!-- link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css"-->
<!-- link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css"-->

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Wood Carver</a></h1>
  
    <h2>Find another pool</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="woodcarver.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/book-links">Books</a></li>
  <li><a href="/about">About Me</a></li>
  <li><a href="/start-here">Start Here</a></li>
  <li><a href="/others-blog">Reading</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/13/ctr/">Ctr</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-13T19:49:52+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>13</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>7:49 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>ctr模型预估</h1>

<h2>Logistic Regression</h2>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/06/computational-advertising/">Computational Advertising</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-06T00:00:00+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>6</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>12:00 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>刘鹏表示，不了解计算广告，就不可能深入地了解互联网，也不太容易真正理解大数据。技术从业者需要从行业、宏观的角度认识这个领域，进而掌握相应的思考方法和技术，包括<strong>商业产品的思路和工作方法，信息检索、机器学习、最优化、博弈论等基础数学工具，以及Hadoop、Spark和其他开源工具为核心的大数据基础设施</strong>等。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/10/24/the-power-of-infomation-and-time/">The Power of Infomation and Time</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-10-24T13:32:56+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>24</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>1:32 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>一个懒惰就白白浪费1500元</h2>

<p>这真实一个愚蠢的教训，人总是不断的钻牛角尖的方式去提高自己的月薪，但是却容易忽视自己生活中的各种犯懒而导致的远远超过自己辛辛苦苦劳动力的价格。
比如我再2016-10-24号发生的自如退租的事情。如果我提前30天解约，只损失70%的押金，提前20天，只损失100%押金，小于20天，而除了押金全陪还要搭上补齐20天房租的钱。我是提前6天提出解决的，这让我损失了1747元，这比钱是我一年买书的钱，一年中请朋友吃饭的钱，两年买衣服的钱，五年看电影的钱。而这笔钱我完全就留心，一个提前的电话就可以搞定。这件事情让我意识到了信息和时间的力量，这才是杠杆最大的赚钱资本。</p>

<p>相比我一天的工资才1000元，这就相当于我有一天是白干的！</p>

<p>当然让我白干的事情还有很多很多，比如对自己财产的放任不管的处理方式（V-V），放在银行里让其贬值。但是如何预防这种事情呢？我为什么空不出足够的精力去增加自己的财产性收入呢？想了想这才是我最大的问题，为什么我的行为会如此愚蠢，为什么我会“放任金钱”从手中流失？</p>

<p>难道是我不喜欢这些事情吗？（嗯，我确实不喜欢！）但是我想更多的应该是没有习惯这种全局的思考，人生有想要保持简单，还是先要把地基打牢固才行。</p>

<p>看来除了信息和时间的力量，最强大的还会自己管理注意力的力量。请把精力放在杠杆大的地方！想想《狼与辛香料》关于货币那章节，还有想想房价的时效性。果然同意劳动是最没有杠杆的赚钱方式，应该腾出时间，腾出精力去想想这些生活方面的！</p>

<p>交学费要有价值才行，不然就是学费，而是挥霍！</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/09/14/learning-how-to-learn/">Learning How to Learn</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-09-14T16:40:30+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>14</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>4:40 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>《Learning how to learn》是一门coursera上一门优秀的课程，已经开播很多期。我在这里开始把这门课程以自己的方式翻译成中文版。希望能给大家带来一些学习方法上的收获，提升大家的学习效率。</p>

<h1>第一章： 大脑中的两种思维方式——聚焦式（focused modes）和发散式（Diffuse modes）</h1>

<p>当你想不出来一个问题的答案时候你会怎么做？对于僵尸来说，那可件简单的事情。他们可以通过不断的把脑袋往墙上撞就可以了。但是活着的大脑则是相当复杂的。事实表明，如果你能多了解一点大脑的工作过程，你将会把学习变得轻松很多，同事少很多挫败感。</p>

<p>万能的研究人员发现我们人类大脑一般有两种思考方式，一种是聚焦式思考方式，另一种是发散式思考方式。
我们非常熟悉聚焦式思考方式，这种方式是通过集中注意力在正在学习和理解的东西上。但是我们不太熟悉发散式方式，这种方式是通过关联一组正在休息的神经元细胞。</p>

<p>我们将通过一个<strong>弹球游戏(pinball game)</strong>的打比来让大家理解这两种思考方式。顺便说
一下，象征和比喻是一种强大的工具来让我们理解一些要学习的东西。</p>

<p><img src="http://woodcarver.oss-cn-shanghai.aliyuncs.com/post/learning_how_to_learn/pinball.png" alt="pinball" /></p>

<p>pinball的内部则充满着小柱子，这个游戏的基本规则是你通过拨动一个弹簧然后射出一个小球，使它达到目的地小柱子上。现在到你的大脑，你的眼睛在前面，耳朵在两旁，然后你的大脑就是pinball内部结构。</p>

<p>下面的图是focused mode的比喻：
<img src="http://woodcarver.oss-cn-shanghai.aliyuncs.com/post/learning_how_to_learn/focused_mode.png" alt="focused mode" /></p>

<p>我们发现其有一些线已经连通了一些柱子，而且这些柱子之间的距离都非常近。看着图中的橘黄色的线，它就代表着一个熟悉的思考模式，也许代表着简单的加法。你在想一些事情，小球就会从底部的小点出发，移动到大脑的里面，然后开始搜索，如果到了小蓝柱子之间有橘黄色连线的时候，思考是非常容易的，因为每个柱子之间距离非常近，还有现成的连线可以达到。</p>

<p>这是一个相当愉快的又熟悉的过程。但是如果我们要到一个熟悉的地方怎么办？比如我们要获得一个新的想法（idea）或者一个新的方法的时候。你既不知道它在哪里，也不知道它长什么样子。例如下图：
<img src="http://woodcarver.oss-cn-shanghai.aliyuncs.com/post/learning_how_to_learn/how_to_reach_new_things.png" alt="how_to_reach_new_things.png" /></p>

<p><strong>你怎么到达下面的绿色连线的部分？</strong></p>

<p>这就是一个典型的如果你要获得什么东西，你首先需要创建它。而通常创建东西的方法和使用东西的方法不一样。这时候就引出了发散式思维方式。
<img src="http://woodcarver.oss-cn-shanghai.aliyuncs.com/post/learning_how_to_learn/different_in_diffuse_mode.png" alt="different_in_diffuse_mode.png" /></p>

<p>我们看到在这种思维下，你看问题的方式会非常不一样。小球会要穿越非常长的距离，而且跨越的范围也非常大。在你的大脑里，你可以创建新的神经元模式在移动小球的过程中。在diffuse mode里面，你思考问题非常广泛。这时候你不能把注意力集中在一起，反而是一种全图景象（big-picture）的过程。这种思考方式不是让你得到一个问题的答案，但是可以至少给你一个解决方案的粗糙的原始方案。</p>

<p>现在神经学科学家发现，你不可能同时处于两种思考模式，而是只能选择其一。这就像一个硬币，要么翻到正面，要么翻到反面，但是不可能两面同时出现。</p>

<p>接下来让我们看看一些名人是怎么学习的。Salvador Dali 一名20世纪非常有名的画家，他被认为是一个非常狂野和疯癫的人。Dali曾经对一个项能提升他绘画效果的技能非常痴迷。这时候他会懒懒的坐在椅子上然后放任的大脑，只是略想想之前集中想的事情。他手里会拿把钥匙，当他快要睡着的时候，钥匙掉在地上发出的响声会吵醒他。紧接着之后他就可收集下刚才的在diffuse mode下的想到的线索和东西，然后开始进入foucsed mode。</p>

<p>也许你会说这种方式只适合于艺术家，但是Thomas Edison（爱迪生），世界上最有名的科学家也使用同样的方法。Edison遇到了一些难题的时候或者新东西，会放松的坐在椅子上，然后手里塞满滚珠，然后开始放松大脑，只是是不是的返回自己刚才专注的事情。当自己快要打瞌睡的时候，滚珠就掉下来。自己被滚珠砸在地上的声音弄醒，然后开始回想刚才在放松的情况下的线索回到集中注意力状态。</p>

<p>所以从上面的过程看来学习一项新东西，你需要在两种思考模式之间来回切换，这样会帮助你有效的学习。这就像你通过举重来锻炼肌肉一样，你不会把所有的锻炼都在一天内做完，相反你会每天锻炼一点。渐渐的肌肉就会长起来。大脑的神经元细胞同样也需要每天锻炼。</p>

<p>了解两种不同的思维方式，后面的课程会介绍怎么<strong>正确</strong>的这两种思考方式来达到最好的学习效果。</p>

<h1>第二章: 拖延症，记忆和睡眠</h1>

<h2>拖延症</h2>

<p>每个人都有拖延症。因为如果你正在做某一项工作时候，这意味着你不能干其他事情。有些人的症状要比另一些人严重，我们在这里会详细讨论拖延症的产生原因，还会给出一些很有用的工具来帮你克服它。</p>

<p>当你不情愿的看着某些东西的时候，这似乎意味着你大脑和痛苦相关的区域正在活跃着。你的大脑，很自然的会倾向于通过转移注意力来停止这种负面情绪。但是这是陷阱。研究人员<strong>发现当人们开始做他们不喜欢的事情时间不久之后不舒服感就会消失</strong>（关键还是要开始做呀！）。这就是你在拖延时候发生的情况。首先，你观察然后得到一个因为某个东西引起的不适的暗示，你不喜欢他，所以你开始转移注意力以此来消除这种因为某些原因引起的不适的感觉。</p>

<p>你会转向某些轻松的事情。结果就是你会<strong>暂时的</strong>感觉到快乐。我们会在后面讨论更多关于拖延的知识。此时我们给出一个克服拖延的工具 —— Pomodoro（番茄时间规划法）。这是一种非常简单的方法，需要的道具只有一个定时器就够了。它把时间化成块，有学习块和休息块。一般一个学习块是25分钟，一个休息块是5分钟。一个学习块加上一个休息块成为一个番茄。具体过程是你首先计划做的事情需要多少时间完成，然后分配给番茄。然后一个番茄一个番茄的做完。（具体建议还是看下《番茄工作法图解》的具体细节）</p>

<p>关键动作：<code>强迫自己做，然后就会顺其自然</code></p>

<h2>记忆</h2>

<p>当我们回忆童年往事的时候，我们是直接从大脑的长期记忆部分取出内容。但是当我们试图理解一个新问题或新概念的时候，我们是先把一些想法放在心中，这是利用工作记忆（短期记忆）。很显然，有时候我们会把长期记忆取出然后放入工作记忆中，这样就可以对它进行思考了。所有这两种记忆是有联系的。</p>

<p>有很多种划分记忆的方法，但是在这里，我们只用两种主要的记忆系统—— 工作记忆（短期记忆，可类比入计算机的内存）和长期记忆（可类比计算机的磁盘）。工作记忆是记忆中承担立刻和有意识的过程部分。研究者过去认为我们的工作记忆大概可以保存7个物品或者事件，但是现在认为只能是大概4个信息块。我们倾向去自动把要记忆的东西<strong>分组</strong>，所以我们的工作记忆实际上可以比我们认为的要大。</p>

<p>尽管你的工作记忆就像一块黑板一样，它其实是一块不怎么好的黑板。你经常需要不断的重复才能把要记忆的东西保留在工作记忆上。举个例子，你要写下以电话号码之前你需要重复好几遍。你应该会发现当你闭眼想要集中注意力的时候总会有别的事情来侵占你工作记忆中有限的槽位（4个）。因此我们知道了短期记忆是一个不怎么有效的黑板。另一种记忆系统——长期记忆，有点像是记忆仓库（看过《头脑特工》的读者们应该会很有画面感）。它分布在大脑的各个地方并且占有很大的面积。不同的长期记忆被储存在不同的地方。研究者表明，如果你想把一个短期记忆（比如一个数学公式）储存进长期记忆中，你至少需要重复几遍来增加以后需要时成功获取的概率。长期记忆的储存量是无限的，它有空间来存放数亿的东西。实际上，在长期记忆中记忆和记忆之间可能会发生互相覆盖，所以除非你练习和重复几次，否则很难找到想要的信息。</p>

<p>长期记忆非常重要，因为它储存着你学习时需要的基础概念和技术。当你尝试新东西的时候，你经常需要使用工作记忆来承载这些知识。如果你想把信息从长期记忆中加载到工作记忆中，你还需要练习几遍才行才能熟练这种获取过程。当然重复也有技巧，就是<strong>不要一共100个单词，一天重复一个单词100遍。而是单词分摊开，一天记忆一遍所有单词，第二天依然，持续100天</strong>。所以记忆一个东西，一个下午重复7次，不如每天重复一次来的效果好。把记忆的过程想象成使用胶水，大脑内部的神经元细胞之间需要时间来建立连接，就想胶水需要时间类风干一样。</p>

<p>关键动作：<code>每天重复一点</code></p>

<h2>睡眠</h2>

<p>你也许会惊讶当你知道人醒着的时候我们的大脑会产生毒素！大脑是怎么排除这些毒素的呢？结果是当你睡觉的时候，你的大脑细胞会缩小，然后细胞之间的空隙会变大，这时候液体可以流过这些细胞进而把毒素清洗出去。所以睡眠，在某种意义上来书就是清洗的时间，是大脑保证自身的卫生和健康的方法。所以让我指出关键点，没有休息好就去考试时候，意味着你运行这一个充满神经毒素的大脑。毒素会让你思考不再那么清洗和快速。</p>

<p>睡眠还有另外一个好处，就是在你睡觉的时候，大脑会重复清醒的时候的知识，加强记忆和连接。所以睡眠并不是浪费时间，当然前提是你已经先尝试集中式思考后播下了进行发散式思考的种子。</p>

<p>当你在睡觉以前学习了一些知识，你有很大概率梦见他们。梦见这些东西能提高你理解它们的概率。</p>

<p>关键动作： <code>睡眠</code></p>

<h1>第三章: Chunking &ndash; The Essentials</h1>

<p>这一章讲到了具体的学习方法。首先还是需要搞清楚我们的大脑到底是怎么运作的。上一章只讲了几了两种基本模式，这一章会继续深入——知识的基石块（Chunking）。这一章从学习的质量入手。首先讲到什么是<strong>学习完成幻想症（Illusions of competence in learning）</strong>，第二个大问题是<strong>过度学习（over learning）</strong>。</p>

<h2>什么是思维块（Chunk）？</h2>

<p>首先我们先学习个英文单词——chunk。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>chunk |tʃʌŋk|
</span><span class='line'>noun
</span><span class='line'>①(piece of meat, fruit, bread, etc.)大块
</span><span class='line'>a chunk of plaster
</span><span class='line'>一块厚厚的灰泥
</span><span class='line'>②colloquial (large amount)相当大的量
</span><span class='line'>a fair chunk of the essay
</span><span class='line'>文章的大部分</span></code></pre></td></tr></table></div></figure>


<p>我们来是拿学习一个新概念为例，一般来说当我们接触一些不熟悉的时候，第一反应这些是“什么东西，完全没有感觉呀！”。这些知识点就像一堆散乱的拼图碎块一样，完全意识不到他们拼接起来后会是一幅完整的图画。</p>

<p><img src="" alt="big_picture" /></p>

<p>Chunking就是一种思维跳跃的过程，它可以帮助你把一些信息有条理的聚合起来。新的逻辑会让这些碎片容易理解，更重要的是能把它们联系起来形成一张更大的图片。仅仅记忆一些事实，而不是理解其中上下文不能帮助你理解你正在学习的东西，也不能帮助你理解这些概念和其他概念是怎么联系起来的。注意到这里这块碎片不能和那块相扣，可以帮助你找到其他的碎片是否和这块相扣。</p>

<p>我们前面谈论过我们的短期记忆一般只能记住4件东西。当你集中注意力的时候，就像头顶上有个章鱼，章鱼的有4个触须通过这4个孔来帮助你把分散在大脑各个部分的信息给连接起来。</p>

<p>记住，这和发散式思维中的随机连接是不一样的。集中注意力并尝试去把大脑中的各个部分连接成一个想法是集中式思考学习方法的一个重要组成部分。这也是常用的帮助你建立一个chunck的方法。有趣的是当你处于压制注意力的情况下，脑前的章鱼就开始丧失了连接信息的能力。<strong>这也就是为什么当你处在愤怒、压力或者害怕的时候，大脑不能高效工作的原因。</strong></p>

<p>chunk是一些信息的有机的结合起来形成一个有意义有用的更大片段。比如你可以认识并说出P、O、P这三个字母，并且把他们结合起来形成另外一个有意义的单词pop。这就是一个chunking的过程。</p>

<p>最好的学习语言方式是在集中注意力的状况下的不断重复练习和记忆，同时搭配上自由式的以此语言为母语的朋友对话练习。这样做的目的就是把基本的单词和语法嵌入到脑中，同时放松自由的使用此门语言来创造你自己新语言模块。集中注意力在练习和重复上面，会创造更强的记忆痕迹，这样帮助你创造更多的chunks。通往专家的路是一点一点来的，小的chunks会逐渐变大变成一门专长，并且所有的专长会成为对你成为一名掌握某种本质的大师的基石。总而言之，就像你稍后会看到的，练习和重复的建造chunks并不是你成为某一技能大师的全部，Chunking会帮助你的大脑运转的更加有效。一旦你形成了一个想法，一个概念或者一个动作，你就不需要再记住原来的那些细小的细节了。你已经得到了主题思想——块，那就是足够了。</p>

<p>举个例子，比如你早晨起来穿衣服。你会觉得这是一件很简单的事情。但是出人意料的是当你意识到影藏在这个简单地动作下的一系列活动。</p>

<h2>如何形成chunk？</h2>

<p>我们现在先来介绍一点怎么形成chunk的背景知识。假如你想学习用吉他弹奏一首曲子，而相应的大脑中的神经元表征是一块相当大的块。你会先听这首歌，也许你还会看别人演奏这首曲子，特别是当你还是为初学者的时候，你会学会怎么抱吉他。对于大多数项目和技能来说，获得一个对掌握东西的大体印象的步骤都是相似的。你经常首先抓住一定曲子的片段，并形成一个微小块(mini-chunks)，这个微小块以后会和其他块连接起来形成大块。例如，经过好几天后，你或许已经学会了使用吉他熟练的弹奏一个乐段，而当你掌握很多乐段后，你可以将这些乐段连接起来，逐渐的把所有的段放在一起后你就学会了这首曲子了。</p>

<p>对于学习运动，比如篮球，足球，高尔夫。你先掌握和练习几个片段必要的技能点。这时候你就是在建立微小块，这些微小块日后会渐渐连接成大块，再后你就可以使用这些大块再形成更大、更复杂的块，之后你可以立即使用这些巨大块。比如你可以在踢足球时使用停球技巧，控制朝你轻轻旋转滚来的足球。最好的组块是那些根深蒂固的，你甚至不需要有意识地去将储存在脑中的模式连接起来。而这也正是将复杂的想法，动作和反应，组成一个单独的组块的意义所在。你可以在学习语言时体会到这点，最开始说的一个简单单词，其中的细微差别，语调和口音就已经需要很多的练习了。即兴造句需要有创造力地将新语言中各种复杂的小组块和较大组块联系起来。为了清晰地表达我的意思，试着重复印度卡纳达语的绕口令吧。</p>

<p>Hi，我是Shilpa Knokani。 我的母语是Kannada，这是一种印度最古老的语言之一。今天我们教你一个Kannada的绕口令，来更我读：“Terikere yri male muru kari kurimari meyuthiddavu”。是不是特别简单？（！！！非母语的我们实际表情）。看来除非你是当地人，否则语言只能一点一点学习。</p>

<p>学习数学和科学涉及到同样的方法。当你学习一个新数学或者科学知识时候，通常会先给你一些简单的问题并且附上解答过程。这是因为当你首次尝试理解怎么解答一个问题的时候，你的大脑会产生称重的认知负担。所以这些例子会帮助你起步。这就像你需要先听一首歌然后才能弹奏这首曲子。大多数的解答细节都在这里，而你的工作仅仅是找出到达目的地的路而已。这些例子可以帮助你看清楚问题的关键特征和隐藏的本质。</p>

<p>在使用示例帮助你形成chunks的过程中需要注意一点，那就是这种方法太容易让你集中在一个单独的步骤而不是步骤之间的联系上。这就是为什么下一步你一定要做的关键步骤。所以请铭记于心，这里并没有仅仅教授你“按部就班的做”，仅仅接受指示而不加思考。实际上学习的过程应该更像是使用一张地图来帮你到达一个新地方。集中注意力在将要去的下一个地方，很快你就会找到你自己想要到达的目的地。你甚至可以找出另一条新路径。</p>

<p><strong>接下来我们进入实战环节——形成chunk的具体操作步骤：</strong></p>

<ol>
<li>不要分散注意力，要全神贯注到要关心的事情上</li>
</ol>


<p>不要分散注意力指的是当你开着电视写着作业，或者隔几分钟查看下手机，这样是会大大增加chunk形成的难度。因为你的大脑并没有真正的聚焦在要学习的东西上。当你首次学习某些东西，你正在努力产生一个新模式，这个模式会连接分布在大脑各个地方的已经存在的模式。从前面的关于记忆的章节我们知道，我们的暂存工作空间平均只有4个槽位，所以当你分散精力的时候会占用这些槽。</p>

<ol>
<li>理解基础的思想，不仅仅是独立的块知识，还有这些块之间的<strong>联系</strong>。</li>
</ol>


<p>联系是非常重要的，我们是不是经常有这种感觉，背了无数的英文单词，但是发现确没有办法把他们使用在对话或者写作中？这就是缺少理解他们联系的典型表现。</p>

<p>而且为使得你真正理解所学的内容，请做<strong>练习</strong>。比如你学习一些科学知识的时候，请合上书然后做一些测试。这样会帮你理解问题，同时也会加快你学习的步伐。当你能动手自己做的时候才是你真正理解这些知识的时候。而如果你只是看过，听过，而没有实际做过，就不要指望能真正的吸收容纳成自己的。因为仅仅看过，过着认为自己理解了，并不意味着你可以自己做出来。这个方面我们后面还会涉及，并且有个专业名词——完成幻想。</p>

<p>练习就是帮助你打破这些知识孤岛，把他们联系起来的一个很有效的方法。它会真正的帮你建立chunk之间的联系路径。学习的有梁祝基本的方式——从上到下的方式，从下到上的方式。从下到上的方式指的是你首先学会一些独立的基本块知识，不断的练习知道熟练，并且在需要时候能够轻易使用。然后在尝试着把这些知识都联系起来，形成更多样的用法。比如你学习一首曲子，应该是一个段落一个段落的练习，然后把各个段落连接起来，形成一首完整的歌。而从上到下的学习方式是你首先基本感受一下这方面的整体蓝图。弄清楚它到底有什么用，适用于那些地方。</p>

<p>所以一个基本的学习方法是：在要学习之前首先浏览下整个章节，大概看下要讲什么内容，每个小节会涉及到什么。这样可以帮助你弄清楚知识的基本的概要。就想有了一个大概的地图，让你能很好地组织后面学习的进行。</p>

<p>如果用神经科学的角度来讲，这种方法可以帮助你了解你需要把构建的chunks放在哪里，各个chunk之间有什么关系。</p>

<p>学习某些知识时候，一般都会有关键指示或者书目，或者概念索引等概要知识。你把这些东西找出来后，再往里面填充细节。尽管有些地方可以会被漏掉，你仍然可以知道整个全景是什么样子的。总结起来就是chunks最好在聚精会神、理解基础思想的时候形成。同时练习可以帮助你抓住中心思想。</p>

<p>这就是形成chunk的主要步骤了。</p>

<h2>知识获得假象（Illusions of Competence）</h2>

<p>这章节的内容非常实用，犀利的指出了我们的<strong>无效学习</strong>。这个章节的内容：</p>

<ul>
<li>回放（Recall）</li>
<li>Illusions of Competence</li>
<li>Mini-testing</li>
<li>Value of making mistakes</li>
</ul>


<p>一种常见的学习方法就是重复的读书本和笔记知识。但是根据心理学家——Jeffrey Karpicke表明这种方法通常笔记另一种简单、实用方法低效很多。而这种方法就是<strong>回放（Recall）</strong>，具体指当你读完一段材料后，不要急着读第二遍，而是把书合上是回忆刚才的所读的信息（最好能在纸上画一个大概的结构地图，或者脑图）。</p>

<p>Karpicke的研究发表在《科学旅程》杂志上面，其中有明显的证据表明这种方法非常可行。实验中学生们被要求先学习一段科学知识，然后做些记忆回访练习。这种动作往复几遍。同时对照组使用其他的学习方法，比如简单的重复读一遍内容，之后的测验结果表明回放的学习方法效果大大好于其他的方法。</p>

<p>当我们在脑中检索知识的时候并不是知识简单的回忆机器而已。这个检索过程本身就能提高学习程序，并且帮助我们开始形成chunks。这种就和回忆一样能帮助我们建立微小的神经元挂钩一样，我们可以把（ It&rsquo;s almost as if the recall process helps build in little neural hooks, that we can hang our thinking on.
？？？）</p>

<p>令研究者更惊讶的是学生们简单读后做回忆联系这种方法并不是最好的方法。更好的学习方法是合上书本后尝试画出关键知识路径图，弄清楚各个部分的关系。但是这种方法的前提是你已经把基础的知识嵌入到了脑子中，不然效果就不会很好。这就像你学习高级象棋策略，但是之前你连象棋的基本规则都没有弄清楚，显然在你不可能成功。</p>

<p>使用回忆、记忆关键点，而不是不过心的读书。这样做会让你更加专注也更加有效。重读只在一种情况下有效，那就是隔一段时间才重读，这样就会形成一种有空间感的重复联系（The only time rereading text seems to be effective, is if you let time pass between the rereading, so that it becomes more of an exercise in spaced repetition. ）。</p>

<p>学习过程就像拼图一样（最好把这幅图想象成无界的），你的大脑瞬时记忆首先是有限的（如前面在记忆章节讲的那样），就像你的手同时只能拿少数的几个拼块。当你把几个拼块通过不断的尝试后形成了一个小幅局部图，那么这局部幅图又变成了一个块，只不过稍微大一些。然后继续拼其他的块，然后散落的块越来越少，而局部块缺越来越大，直到最后把几幅局部图拼接起来就是一幅大图景。</p>

<p>现在你明白为什么记忆知识片段，同时建立知识片段之间的联系是学习知识和解决问题的关键所在。但是假如你只是看过某个知识，然后告诉自己：“Oh yeah，我会了！”。但是这个知识还并有真正变成你的。你几乎没有做任何事情让这些知识嵌入你的大脑中。仅仅是瞥一眼后就认为自己就能把知识学到就是最大的“学习完成幻想（Illusions of Competence）”。你必须让这些信息在脑中待一段时间并且做足够的联系和创造性思考延伸。<strong>还有就是注意要谨慎的使用高亮和划线（绝对的恶习）</strong>。如果满篇都是高亮或者划线，其实就是等于没有任何作用，除了使得书本更脏了外。此次之外过度的圈一些重点会让你愚弄你自己，让自己暗示相信自己圈的重点知识已经记在脑子中了，但其实不是。所以请在划重点前先仔细分析下真正的重点，并且尽量减少划线文字的面积。<strong>有一个更好的方法就是使用在旁边写下自己的疑问和理解笔记，比单纯的划线要好的多</strong>。</p>

<p>Jeff Karpicke还研究发现其他相关的领域 —— 学习假象。 有些学生总是不断的重读他们的笔记或者课本，是因为当他们手边就放着书或者开着google（百度），就会想当然的认为自己已经把这些知识装到脑子里面了，但是其实不是，因为太容易查看课本或者网络而放弃坚持努力使用recall（回忆，具体方法上面有说明），这样会导致一些知识只有在有课本和网络帮助下才会的知识，但是脱离这些手头可取的材料后并没有真正的学习到这些。</p>

<p>这就提醒我们，如果我们只采用照搬课本，花大量的时间不断机械重复，并不能实际把知识学习到。而一个很有用的来鉴别你是自己骗自己已经学会了，还是真正的学会的方法就是<strong>做练习</strong>， 测试你的学习成果。</p>

<p>在某种意义上来说，recall（回顾）也是一个种测试。让你明白你是否真正的掌握知识。当你在练习中出现了错误，这其实是一个非常好的事情。你不想重复你的错误，但是在大考试之前在小测试中犯错是非常有价值的。因为这些错误可以帮你了解自己在哪些方面做得不对，理解有偏差，并且做及时的纠正，从而学习的更好。</p>

<p>现在你已经意识到了回顾是一件非常强大的工具。但是还有另外一个技巧，那就是做回顾练习的时候尽量挑选和你平时学习不同的地方，这样会更加加深你的学习成果。你也许没有意识到，但是你在学习新的知识的时候，你会建立知识和周围环境微妙的联系。也许在你熟悉的环境中你能回忆起来的知识更多，但是当你考试的时候，往往是在另一个环境中，而这个环境你并不是熟悉，从而影响你的发挥。所以做回顾练习时候保持场地的多样性，会让让知识和环境脱节，不会发生联系，从而可以轻松在各种场合调用知识。</p>

<h2>过度学习、发生溺水、Einstellung 和 Interleaving（混洗）</h2>

<p>这章又要讲一大推概念了！不过这些概念都有巨大指导意义。有的是指出学习中遇到的问题，有的是指导怎么正确学习。</p>

<h2>过度学习（Over learning）</h2>

<p>什么叫过度学习？<strong>这种其实是指的当你不断的重复学习你已经掌握的知识</strong>。是不是很奇怪，有人会对已经掌握的知识还花功夫学习吗？还真有，比如当一个工人学习会了怎么操作机器，日复一日的重复，到后期基本上闭着眼睛都可以做到了。这种“过度学习”也许在某些情况下是好事，毕竟我们都希望“不动大脑的工作”。但是过度学习有它致命的缺点，第一很明显就是浪费时间，第二是当我们特别熟悉某些知识后，会把这种知识作为一个条件反射的方式来呈现，比如背诵圆周率一样，这样就没有办法进入一个种深入思考的模式。当这种知识是易变的情况下，再使用这种方式就会变成生搬硬套，比如千变万化的数学题。想想那些在考前背题的我们。</p>

<p>事实表明，一旦你一次性学习完了基础知识，继续再过度地重复这些知识并不会加强你想要连接的长期记忆。更糟糕的是只是聚焦于机械式的学习只会锻炼简单的技术性知识。经过一段时间后，你以为你使用这些“知识”解决一切问题了，但事实上你没有能力应用大部分东西。一般来说复习是一件很有意义的事情，这样可以加深神经元的强度和深度。但是如果你只复习你已经掌握的很好的知识，这样同样会让你产生知识习得假象，让你认为你掌握了所有知识，但是其实你是掌握的那部分相对于你来说比较容易的部分。所以你要改变策略，你要把更多的权重倾向于对于你来说比较难的那部分。这种策略就叫<strong>刻意学习</strong>。而这也是区分好学生和优秀学生的一个根本性策略。</p>

<p>上述的一切都与一个概念相关——<strong>定势思维（Einstellung）</strong>。</p>

<p>在这种现象中，你首先在脑海中直接浮现一种想法，而恰恰是这个你牢记熟悉的想法或者思考模式阻碍了你需求其他更好的方案。这就是思维定势的致命缺点。</p>

<p>密集式的（即在短时间内大量重复学习的内容）使用专注式学习模式，并且你以前习得的思维模式也会导致你建立一系列固定模式。而这些正式阻碍你到达真正有效的地方。碰巧的是，在德语中思维定势意味着观念模式（mindset）。基本上你可以把思维定势理解为一个路障，因为当你在首次寻找某些东西时候的情况很相似。由于有时候你对正在发生的事情或者你必须要做的事情的初始感觉很多时候是错误，这种错误的理解很容易发生在体育和科学学习中，更不用提其他学科了。所以在你学习新知识的时候就需要先清楚掉这些错误的旧思想和方法。</p>

<p>学生在学习中经常犯的错误是在学会游泳之前就直接跳入水中。换句话说就是他们盲目的开始做家庭作业，而之前没有看课本、出席课堂、浏览在线课程或者和熟悉此方面的人讨论。这种方法只会让你沉下去。学会一个新东西，并不只是学会这个范围的东西，还要和其他的不同的知识进行交互。最好的学习方法就是不断的在需要不同技巧和策略的问题和解决方案之间转换。这就叫做交替学习（interleaving）。</p>

<p>一旦你对学习技术有了一个基础的印象，就想在辅助轮的帮助下学骑自行车，就要开始在不同的问题、方法、概念和过程中交替练习。说起来这个概念有点困难。一个书中给定的章节，比如，一般是为了介绍特定的技术的，所以当你开始这个章节的学习时候，你就知道这个章节会用到什么技巧你将要用到。（补充一个场景就是，一般我们做数据课本某一章节的习题的时候，比如余弦定理，我们就知道这些练习题肯定是用了余弦公式。但是当把这些习题放到总和期末考试，我们未必能立即想起使用余弦定理。）所以还是尽量把学过的都混起来。或者你刻意的让自己是不是问问自己为什么使用这种技巧哦解决一些问题而不用其他的。你想让你的大脑习惯这种思想，仅仅知道怎么使用刚学习的概念、方法或者问题解决方案是不够的。你还要知道什么时候用。要贯彻交替学习的思想，比如通过在不同章节中切换问题，肯能阅读貌似让你学习更困难的了一点，但是实际上，这样会帮助学习的更深入。交替学习室非常重要的。尽管联系和重复对于建立坚实的神经模式是非常重要的，而交替的方法开启了灵活性和创造性的空间。这是让你离开练习和重复的地方，并且开始思考的更深入。当你交替的学习一个科目或者学科的时候你就开始使用哪个学科的知识开发你的创造能力。当你开始在不同学科之间交替学习时候，你可以更容易的建立不同领域知识块之间有趣的新连接，而这些连接可以进一步提升你的创造力甚至。当然，在艰深的领域建立牢固的知识块需要时间，所以有时候这里有所权衡。成为几个领域的专家意味着你可以从一个领域到另一个领域带来非常新的思想，但是这样也可能你擅长一个领域或者多个没有和那些仅仅专注于一个领域的人有深度。另一方面，如果你仅仅只专注于一个领域，你业务了解的非常深入但是你可能会进一步深陷于你熟悉的思考方式，而不可能去掌握新的思想。</p>

<p>科学哲学家Thomas Kuhn发现科学届中的大多数的重大成就不是年轻人就是那些原本接受的是另一个领域的人带来的。这些人不会轻易地陷入思维定式，因为先前的训练而把思想禁锢住。</p>

<p>最后，不要误认为学习仅仅只是从教师或者课本上获得。当你在叫一个小孩怎么有效的处理欺凌，或者你修复了一个漏水的水龙头，又或者你快速的打包好了去香港商务旅行的行李，所有这些说明了不同方面的学习的结果（the outcomes of important aspects of learning，学习的重要方面的结果or重要方面学习结果）。物理学家费曼在他的工作中，通过观察别人在餐厅里扔一个碟子而受到启发，而这项工作的成果让他获得诺贝尔奖。电视台节目“干尽苦差事”和“得有人做”的Mike Rowe展现了在大量的不同非学术领域的学习是多么的重要和有趣。</p>

<h2>资料列表</h2>

<ul>
<li>番茄图解法</li>
<li>拖延症（procrastination）</li>
<li>意志力（willpower）</li>
<li>习惯的力量（the power of habits）</li>
</ul>


<p>Interleaving your studies, making it a point to review for a test</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/09/04/data-file-organization/">Data File Organization</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-09-04T17:01:19+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>4</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>5:01 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content">
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/08/31/introduce-hive/">Introduce Hive</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-08-31T22:57:57+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>31</span><span class='date-suffix'>st</span>, <span class='date-year'>2016</span></span> <span class='time'>10:57 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>Rcfile的设计</h1>

<ul>
<li>key/value</li>
<li>column-store and row-store , why?
row-store: fast loading data in real-time in HDFS, because data coming by row and will be stored in one place event in one block. But it can not support fast ad-hoc query.</li>
</ul>


<p>怎么衡量一个文件组织方式？答案只有一个，那就是它满不满足使用性能？
好的，对于一个文件我们要做的事情无非就是：读，写。
读有又，位置和数据大小的特性。比如按位置划分就有随机读，顺序读，逆序读等等，大小就是读一条数据，一片数据。再把位置和大小一结合，呵呵！是不是很复杂？
对于hive来说，其读特性就是：读一行也行，读一列也快，还有更牛的是还能建立索引。</p>

<p>写的话，也有位置和大小之分。随机写，在头位置写，在未位置写。大小写入一条数据，写入一片数据。再一结合。。。。</p>

<p>hive写的就是追加，这也是为什么要先水平在垂直，要的就是加载数据速度，还有实时加载数据的特性。因为打开一个节点的比打开无数节点靠谱很多不是吗？还往单机上说，就是打开一个文件总比打开多个文件写要快不是吗？
同时如果写操作是流式的，那么每次写入其实都需要重新组织数组块，进行压缩。</p>

<p>如果把读和写结合起来就产生了更邪恶的操作，那就是删除和更新。</p>

<h1>HSQL怎么解析到MapReduce？</h1>

<h2>怎么使用MapReduce实现Join？</h2>

<h2>怎么使用MapReduce实现Group By？</h2>

<h2>怎么使用MapReduce实现Distinct？</h2>

<h1>如何在Hive中加载一个外部的脚本文件？</h1>

<h1>写UDF, UDAF, UDTF</h1>

<p>Hive提供UDF, UDAF, UDTF三种接口来给用户扩展sql的功能。当然为什么要有三个接口呢？他们有什么区别？这个我们下面会依次讲到。</p>

<p>首先我们需要知道现在都有哪些实现好的函数，就不用再造轮子了是吧！</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; show functions;
</span><span class='line'>!  
</span><span class='line'>!=  
</span><span class='line'>......
</span><span class='line'>
</span><span class='line'>&gt; describe function max;</span></code></pre></td></tr></table></div></figure>


<p>show functions这个命令可以列出现有的函数，而describe function function-name会列出具体的函数描述。</p>

<p>写自己的函数前，我们先要明确下我们的函数到底会怎么被Hive运行？会在那个阶段运行？这个就不得不说SQL语句的解析了。一般SQL的解析顺序是：</p>

<ul>
<li>from</li>
<li>on</li>
<li>join</li>
<li>where</li>
<li>group by</li>
<li>having</li>
<li>select</li>
<li>distinct</li>
<li>union</li>
<li>order by</li>
<li>limit</li>
</ul>


<p>本质上SQL是一个种集合代数运算操作的语言，每一种操作都是一种代数操作。
这个顺序基本可以这么理解：首先需要确定数据源（from后面的表），然后数据确定范围（where条件筛选），然后对这个数据进行分组（group），然后选择要展示的列（select），然后可以对选择的数据集进行排序（order by）。后面如果还有一个数据集那么可以union。其中还有像having，distinct和limit操作的顺序我暂时还不能理解这里就不讲了，还有发现distinct的执行顺序和group by并不在一起让而且在select后面，也许这里就会产生一些写法上的注意点。其中这个排序也可能在不同的数据库引擎中执行顺序不一样。
具体详情参看<a href="http://blog.jobbole.com/55086/">这篇文章</a>。</p>

<p>那么hive的函数要做到在SQL语句哪个部分都能运行，所以对函数的语义一定要弄清楚。而且一定要把函数处理过程想想成流式的，因为在SQL中所有的操作都是流式操作。</p>

<ol>
<li>UDF只能实现一进一出的操作, 即UDF只能操作一行的数据，而要操作多行的数据需要使用UDAF实现</li>
<li>实现聚合函数请用UDAF， 解决进多出一</li>
<li>UDTF(User-Defined Table-Generating Functions) 用来解决 输入一行输出多行(On-to-many maping) 的需求</li>
</ol>


<h2>怎么解决hive中的数据倾斜问题</h2>

<h2>hive sql优化</h2>

<ul>
<li>裁剪列，不要写不查的列</li>
<li>裁剪分区，如果是子查询限制条件一般放在子查询内部</li>
<li>Join1 —— 小表前置，想想hash join的过程</li>
<li>Join2 ——</li>
</ul>


<h2>推荐书目</h2>

<ul>
<li><a href="https://www.amazon.cn/Hadoop%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E6%80%80%E7%89%B9/dp/B016OFNZYM/ref=sr_1_2?ie=UTF8&amp;qid=1477288333&amp;sr=8-2&amp;keywords=hadoop%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97">Hadoop权威指南</a></li>
</ul>


<p>Hadoop的基础书籍，基本上可以说是必读书。书中详细的介绍了hadoop的发展历史，设计思想、任务调度框架、计算框架编程、测试等。是进入hadoop世界的一本非常好的材料。而且作者本身就是hadoop的以为重要代码贡献者。</p>

<ul>
<li><a href="https://www.amazon.cn/MapReduce%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%88%E7%BA%B3/dp/B00NA989GU/ref=sr_1_1?ie=UTF8&amp;qid=1477288440&amp;sr=8-1&amp;keywords=mapreduce%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">MapReduce设计模式</a></li>
</ul>


<p>当你有了mapreduce的基础知识后，再看这本书，就会非常容易理解Hive中的HQL是怎么转化成map reduce任务了。最重要的是当你理解了转化的过程和最终的map reduce任务，就可以着手优化HQL语句，解决数据倾斜、冗余查询操作等问题。涉及的内容非常实用，给出的示例可执行度很强。对于编写mapreduce程序也有巨大提升。</p>

<ul>
<li><a href="http://www.cnblogs.com/yurunmiao/p/4745951.html">Hadoop RCFile存储格式详解（源码分析、代码示例）</a></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/08/22/design-pattern/">Design Pattern</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-08-22T23:00:57+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>22</span><span class='date-suffix'>nd</span>, <span class='date-year'>2016</span></span> <span class='time'>11:00 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content">
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/08/14/how-to-manipulate-binary-stream/">How to Manipulate Binary Stream</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-08-14T20:47:13+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>14</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>8:47 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content">
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/08/14/how-to-use-jmock/">How to Use Jmock</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-08-14T14:35:32+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>14</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>2:35 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.jmock.org/expectations.html">jmock官网</a></p>

<h1>测试框架</h1>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void testSomeAction() {
</span><span class='line'>    ... set up ...
</span><span class='line'>
</span><span class='line'>    context.checking(new Expectations()
</span><span class='line'>        ... expectations go here ...
</span><span class='line'>    );
</span><span class='line'>
</span><span class='line'>    ... code being tested ...
</span><span class='line'>
</span><span class='line'>    context.assertIsSatisfied();
</span><span class='line'>
</span><span class='line'>    ... other assertions ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>其中最重要的一个步骤就是context.checking。这个方法中定义的expectation就是需要关注的。也就是你要模拟的方法的输入和输出。
其他格式是这样的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>invocation-count (mock-object).method(argument-constraints);
</span><span class='line'>    inSequence(sequence-name);
</span><span class='line'>    when(state-machine.is(state-name));
</span><span class='line'>    will(action);
</span><span class='line'>    then(state-machine.is(new-state-name));</span></code></pre></td></tr></table></div></figure>


<p>其每个短语的具体意思如下：</p>

<table>
<thead>
<tr>
<th>one    </th>
<th>The invocation is expected once and once only.</th>
</tr>
</thead>
<tbody>
<tr>
<td>exactly(n).of</td>
<td> The invocation is expected exactly n times. Note: one is a convenient shorthand for exactly(1).</td>
</tr>
<tr>
<td>atLeast(n).of </td>
<td>The invocation is expected at least n times.</td>
</tr>
<tr>
<td>atMost(n).of   </td>
<td>The invocation is expected at most n times.</td>
</tr>
<tr>
<td>between(min, max).of   </td>
<td>The invocation is expected at least min times and at most max times.</td>
</tr>
<tr>
<td>allowing   </td>
<td>The invocation is allowed any number of times but does not have to happen.</td>
</tr>
<tr>
<td>ignoring   </td>
<td>The same as allowing. Allowing or ignoring should be chosen to make the test code clearly express intent.</td>
</tr>
<tr>
<td>never  </td>
<td>The invocation is not expected at all. This is used to make tests more explicit and so easier to understand.</td>
</tr>
</tbody>
</table>


<p>所有的函数都是可以选的，例如你可以如下组合你的exception。</p>

<h1>例子</h1>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void testReturnsCachedObjectWithinTimeout() {
</span><span class='line'>    context.checking(new Expectations()
</span><span class='line'>        oneOf (clock).time(); will(returnValue(loadTime));
</span><span class='line'>        oneOf (clock).time(); will(returnValue(fetchTime));
</span><span class='line'>
</span><span class='line'>        allowing (reloadPolicy).shouldReload(loadTime, fetchTime); will(returnValue(false));
</span><span class='line'>
</span><span class='line'>        oneOf (loader).load(KEY); will(returnValue(VALUE));
</span><span class='line'>    );
</span><span class='line'>
</span><span class='line'>    Object actualValueFromFirstLookup = cache.lookup(KEY);
</span><span class='line'>    Object actualValueFromSecondLookup = cache.lookup(KEY);
</span><span class='line'>
</span><span class='line'>    context.assertIsSatisfied();
</span><span class='line'>    assertSame("should be loaded object", VALUE, actualValueFromFirstLookup);
</span><span class='line'>    assertSame("should be cached object", VALUE, actualValueFromSecondLookup);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/07/29/introduce-cap/">Introduce CAP</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-07-29T10:04:53+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>29</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>10:04 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>这篇博文主要是对<a href="http://www.infoq.com/cn/articles/cap-twelve-years-later-how-the-rules-have-changed/">《CAP理论十二年回顾："规则"变了》</a>的读后感。</p>

<h1>CAP到底讲什么，为什么不能同时满足？</h1>

<p>首先明确一点，CAP是一个分布式系统的特性，如果你没有多个服务节点，就不可能发生分区。先解释下概念：
- C —— 执行的结果能同时反映到所有节点上。等同于所有节点访问同一份最新的数据副本。也许这里需要很多的具体不变性约束，比如主键不能重复。
- A —— 这个是指访问的节点是正常的，那么就能正常执行请求（所以和P的一个冲突点就是当系统部分失效，这个系统到底是判定为失效还是正常？）
- P —— 这个特性是说当系统的节点之间通信出现了问题，导致之间不能同步，然后还能继续提供服务。
其实我第一次读这个概念，就是不明白为啥这三个方面不能全部同时获得。然后看了个这个例子：</p>

<blockquote><p>理解CAP理论的最简单方式是想象两个节点分处分区两侧。允许至少一个节点更新状态会导致数据不一致，即丧失了C性质。如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了A性质。除非两个节点可以互相通信，才能既保证C又保证A，这又会导致丧失P性质。一般来说跨区域的系统，设计师无法舍弃P性质，那么就只能在数据一致性和可用性上做一个艰难选择。不确切地说，NoSQL运动的主题其实是创造各种可用性优先、数据一致性其次的方案；而传统数据库坚守ACID特性（原子性、一致性、隔离性、持久性），做的是相反的事情。下文“ACID、BASE、CAP”小节详细说明了它们的差异。</p></blockquote>

<p>上面的例子说的太清楚了，当分布式系统发生了节点之间通信失败，就相当于一个整体的服务发生断裂，分成了几个服务块。从而丢失了其对等性（即从任意一个节点都可以访问到整个系统）。然后这个时候如果其中一部分提供服务，比如写操作通过一节点写入了，但是因为不能通信没有办法复制到其他节点，导致了系统的不一致性。这样就就丢失了C，但是还好保住了A。
接着如果要追求C，那么只有等节点之间的通信成功才行，那么就需要写入操作延迟或者这个期间拒绝服务。那么都不能服务了，自然就没有了A。</p>

<p>所以来说当没有发生分区的时候，C和A可以完美保持。但是发生了分区，那么要容错，C和A可能就不能同时保持。
其实这不是一个3选2的问题，因为你没办法选择系统不分区，当通信出问题这个是能选择的吗？这个是故障，你有办法选择故障？所以其实所有的分布式系统都是在C和A之间进行设计权责。</p>

<h1>C和A之间选择不是0和1的选择，而是一种连续式选择</h1>

<p>从上面的例子看，好像选择C就必须放弃A，反之亦然。但是其实所有这些都有中间方案。C和A的定义也有各种灰度定义。
比如C的定义，最严格的定义就是一个分布式事务结束后，所有的副本在任何时刻都是一致的。但是这个定义可以放宽。时间不在是同时，而是一段时间，给一个时间窗口。或者一阶段内可以不一致，但最终变成一致的。比如上面的例子中，在发生分区的时候，可以暂时不一致，等到通信问题解决了，开始恢复一致性。</p>

<p>而对于A的定义来说，也是有各种层次，在发生分区的时候，可以选择限制部分操作，同时提供一个些事后比较好恢复的操作。</p>

<h1>一种经典的系统设计模式</h1>

<p>因为在分布式系统中，基本是没有办法选择不要分区的，所以为了保证系统的可用性，和一致性的博弈，经典的设计模式就是分情况对待。当不发生分区的时候保证完美的CA，到出现了分区，进入分区模式，等待分区恢复后，恢复系统，最终达到一致性后，再次进入完美CA状态。</p>

<p><img src="../images/posts/CAP1.png" alt="" /></p>

<ul>
<li>检测到分区开始</li>
<li>明确进入分区模式，限制某些操作，并且</li>
<li>当通信恢复后启动分区恢复过程</li>
</ul>


<p>最后一步的目的是恢复一致性，以及补偿在系统分区期间程序产生的错误。</p>

<p>当系统进入到分区模式，它有两种可行的策略。其一是限制部分操作，因此会削弱可用性。其二是额外记录一些有利于后面分区恢复的操作信息。系统可通过持续尝试恢复通信来察觉分区何时结束。</p>

<h1>副本</h1>

<p>一谈到副本，最大的问题就是其一致性，这个问题不仅仅是在分布式系统中涉及，只不过分布式系统是鼓励副本的存在，而在这个基础上开始设计一套一套的解决方案。但相对其他领域——比如设计模式OOD，关系数据范式都是从另一个方向把<strong>重复（副本）扼杀在摇篮中</strong>，比如策略模型，把能公用的都抽象出来复用。</p>

<h1>可怕的一致性</h1>

<ol>
<li>一个场景，一个问题</li>
<li>如何解决这个问题？</li>
<li>这个解决方法是错的吗？</li>
<li>这个方法是对的吗？</li>
<li><p>有没有更优的解法？</p></li>
<li><p>隐喻，一个直观的例子</p></li>
<li>过度到实际的模型</li>
<li>证明模型</li>
<li>实际用途</li>
</ol>


<h1>reference</h1>

<ul>
<li><a href="https://martin.kleppmann.com/2015/05/11/please-stop-calling-databases-cp-or-ap.html">Please stop calling databases CP or AP</a></li>
<li><a href="https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed">CAP Twelve Years Later: How the &ldquo;Rules&rdquo; Have Changed
</a></li>
<li><a href="http://www.cnblogs.com/esingchan/p/3917718.html">分布式理论之一：Paxos算法的通俗理解</a></li>
<li><a href="http://www.cnblogs.com/endsock/p/3480093.html">Paxos算法细节详解(一)&ndash;通过现实世界描述算法</a></li>
</ul>

</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/2">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/11/13/ctr/">Ctr</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/11/06/computational-advertising/">Computational Advertising</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/10/24/the-power-of-infomation-and-time/">The Power of Infomation and Time</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/09/14/learning-how-to-learn/">Learning How to Learn</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/09/04/data-file-organization/">Data File Organization</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2017 - Wood Carver -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
