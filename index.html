
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Wood Carver</title>
  <meta name="author" content="Wood Carver">

  
  <meta name="description" content="《Learning how to learn》是一门coursera上一门优秀的课程，已经开播很多期。我在这里开始把这门课程以自己的方式翻译成中文版。希望能给大家带来一些学习方法上的收获，提升大家的学习效率。 第一章： 大脑中的两种思维方式——聚焦式（focused modes）和发散式（ &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://woodcarver.github.io/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Wood Carver" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/libs/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!-- link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css"-->
<!-- link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css"-->

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Wood Carver</a></h1>
  
    <h2>Find another pool</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="woodcarver.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/book-links">Books</a></li>
  <li><a href="/about">About Me</a></li>
  <li><a href="/start-here">Start Here</a></li>
  <li><a href="/others-blog">Reading</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/09/14/learning-how-to-learn/">Learning How to Learn</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-09-14T16:40:30+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>14</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>4:40 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>《Learning how to learn》是一门coursera上一门优秀的课程，已经开播很多期。我在这里开始把这门课程以自己的方式翻译成中文版。希望能给大家带来一些学习方法上的收获，提升大家的学习效率。</p>

<h1>第一章： 大脑中的两种思维方式——聚焦式（focused modes）和发散式（Diffuse modes）</h1>

<p>当你想不出来一个问题的答案时候你会怎么做？对于僵尸来说，那可件简单的事情。他们可以通过不断的把脑袋往墙上撞就可以了。但是活着的大脑则是相当复杂的。事实表明，如果你能多了解一点大脑的工作过程，你将会把学习变得轻松很多，同事少很多挫败感。</p>

<p>万能的研究人员发现我们人类大脑一般有两种思考方式，一种是聚焦式思考方式，另一种是发散式思考方式。
我们非常熟悉聚焦式思考方式，这种方式是通过集中注意力在正在学习和理解的东西上。但是我们不太熟悉发散式方式，这种方式是通过关联一组正在休息的神经元细胞。</p>

<p>我们将通过一个<strong>弹球游戏(pinball game)</strong>的打比来让大家理解这两种思考方式。顺便说
一下，象征和比喻是一种强大的工具来让我们理解一些要学习的东西。</p>

<p><img src="http://woodcarver.oss-cn-shanghai.aliyuncs.com/post/learning_how_to_learn/pinball.png" alt="pinball" /></p>

<p>pinball的内部则充满着小柱子，这个游戏的基本规则是你通过拨动一个弹簧然后射出一个小球，使它达到目的地小柱子上。现在到你的大脑，你的眼睛在前面，耳朵在两旁，然后你的大脑就是pinball内部结构。</p>

<p>下面的图是focused mode的比喻：
<img src="http://woodcarver.oss-cn-shanghai.aliyuncs.com/post/learning_how_to_learn/focused_mode.png" alt="focused mode" /></p>

<p>我们发现其有一些线已经连通了一些柱子，而且这些柱子之间的距离都非常近。看着图中的橘黄色的线，它就代表着一个熟悉的思考模式，也许代表着简单的加法。你在想一些事情，小球就会从底部的小点出发，移动到大脑的里面，然后开始搜索，如果到了小蓝柱子之间有橘黄色连线的时候，思考是非常容易的，因为每个柱子之间距离非常近，还有现成的连线可以达到。</p>

<p>这是一个相当愉快的又熟悉的过程。但是如果我们要到一个熟悉的地方怎么办？比如我们要获得一个新的想法（idea）或者一个新的方法的时候。你既不知道它在哪里，也不知道它长什么样子。例如下图：
<img src="http://woodcarver.oss-cn-shanghai.aliyuncs.com/post/learning_how_to_learn/how_to_reach_new_things.png" alt="how_to_reach_new_things.png" /></p>

<p><strong>你怎么到达下面的绿色连线的部分？</strong></p>

<p>这就是一个典型的如果你要获得什么东西，你首先需要创建它。而通常创建东西的方法和使用东西的方法不一样。这时候就引出了发散式思维方式。
<img src="http://woodcarver.oss-cn-shanghai.aliyuncs.com/post/learning_how_to_learn/different_in_diffuse_mode.png" alt="different_in_diffuse_mode.png" /></p>

<p>我们看到在这种思维下，你看问题的方式会非常不一样。小球会要穿越非常长的距离，而且跨越的范围也非常大。在你的大脑里，你可以创建新的神经元模式在移动小球的过程中。在diffuse mode里面，你思考问题非常广泛。这时候你不能把注意力集中在一起，反而是一种全图景象（big-picture）的过程。这种思考方式不是让你得到一个问题的答案，但是可以至少给你一个解决方案的粗糙的原始方案。</p>

<p>现在神经学科学家发现，你不可能同时处于两种思考模式，而是只能选择其一。这就像一个硬币，要么翻到正面，要么翻到反面，但是不可能两面同时出现。</p>

<p>接下来让我们看看一些名人是怎么学习的。Salvador Dali 一名20世纪非常有名的画家，他被认为是一个非常狂野和疯癫的人。Dali曾经对一个项能提升他绘画效果的技能非常痴迷。这时候他会懒懒的坐在椅子上然后放任的大脑，只是略想想之前集中想的事情。他手里会拿把钥匙，当他快要睡着的时候，钥匙掉在地上发出的响声会吵醒他。紧接着之后他就可收集下刚才的在diffuse mode下的想到的线索和东西，然后开始进入foucsed mode。</p>

<p>也许你会说这种方式只适合于艺术家，但是Thomas Edison（爱迪生），世界上最有名的科学家也使用同样的方法。Edison遇到了一些难题的时候或者新东西，会放松的坐在椅子上，然后手里塞满滚珠，然后开始放松大脑，只是是不是的返回自己刚才专注的事情。当自己快要打瞌睡的时候，滚珠就掉下来。自己被滚珠砸在地上的声音弄醒，然后开始回想刚才在放松的情况下的线索回到集中注意力状态。</p>

<p>所以从上面的过程看来学习一项新东西，你需要在两种思考模式之间来回切换，这样会帮助你有效的学习。这就像你通过举重来锻炼肌肉一样，你不会把所有的锻炼都在一天内做完，相反你会每天锻炼一点。渐渐的肌肉就会长起来。大脑的神经元细胞同样也需要每天锻炼。</p>

<p>了解两种不同的思维方式，后面的课程会介绍怎么<strong>正确</strong>的这两种思考方式来达到最好的学习效果。</p>

<h1>第二章: 拖延症，记忆和睡眠</h1>

<h2>拖延症</h2>

<p>每个人都有拖延症。因为如果你正在做某一项工作时候，这意味着你不能干其他事情。有些人的症状要比另一些人严重，我们在这里会详细讨论拖延症的产生原因，还会给出一些很有用的工具来帮你克服它。</p>

<p>当你不情愿的看着某些东西的时候，这似乎意味着你大脑和痛苦相关的区域正在活跃着。你的大脑，很自然的会倾向于通过转移注意力来停止这种负面情绪。但是这是陷阱。研究人员<strong>发现当人们开始做他们不喜欢的事情时间不久之后不舒服感就会消失</strong>（关键还是要开始做呀！）。这就是你在拖延时候发生的情况。首先，你观察然后得到一个因为某个东西引起的不适的暗示，你不喜欢他，所以你开始转移注意力以此来消除这种因为某些原因引起的不适的感觉。</p>

<p>你会转向某些轻松的事情。结果就是你会<strong>暂时的</strong>感觉到快乐。我们会在后面讨论更多关于拖延的知识。此时我们给出一个克服拖延的工具 —— Pomodoro（番茄时间规划法）。这是一种非常简单的方法，需要的道具只有一个定时器就够了。它把时间化成块，有学习块和休息块。一般一个学习块是25分钟，一个休息块是5分钟。一个学习块加上一个休息块成为一个番茄。具体过程是你首先计划做的事情需要多少时间完成，然后分配给番茄。然后一个番茄一个番茄的做完。（具体建议还是看下《番茄工作法图解》的具体细节）</p>

<p>关键动作：<code>强迫自己做，然后就会顺其自然</code></p>

<h2>记忆</h2>

<p>当我们回忆童年往事的时候，我们是直接从大脑的长期记忆部分取出内容。但是当我们试图理解一个新问题或新概念的时候，我们是先把一些想法放在心中，这是利用工作记忆（短期记忆）。很显然，有时候我们会把长期记忆取出然后放入工作记忆中，这样就可以对它进行思考了。所有这两种记忆是有联系的。</p>

<p>有很多种划分记忆的方法，但是在这里，我们只用两种主要的记忆系统—— 工作记忆（短期记忆，可类比入计算机的内存）和长期记忆（可类比计算机的磁盘）。工作记忆是记忆中承担立刻和有意识的过程部分。研究者过去认为我们的工作记忆大概可以保存7个物品或者事件，但是现在认为只能是大概4个信息块。我们倾向去自动把要记忆的东西<strong>分组</strong>，所以我们的工作记忆实际上可以比我们认为的要大。</p>

<p>尽管你的工作记忆就像一块黑板一样，它其实是一块不怎么好的黑板。你经常需要不断的重复才能把要记忆的东西保留在工作记忆上。举个例子，你要写下以电话号码之前你需要重复好几遍。你应该会发现当你闭眼想要集中注意力的时候总会有别的事情来侵占你工作记忆中有限的槽位（4个）。因此我们知道了短期记忆是一个不怎么有效的黑板。另一种记忆系统——长期记忆，有点像是记忆仓库（看过《头脑特工》的读者们应该会很有画面感）。它分布在大脑的各个地方并且占有很大的面积。不同的长期记忆被储存在不同的地方。研究者表明，如果你想把一个短期记忆（比如一个数学公式）储存进长期记忆中，你至少需要重复几遍来增加以后需要时成功获取的概率。长期记忆的储存量是无限的，它有空间来存放数亿的东西。实际上，在长期记忆中记忆和记忆之间可能会发生互相覆盖，所以除非你练习和重复几次，否则很难找到想要的信息。</p>

<p>长期记忆非常重要，因为它储存着你学习时需要的基础概念和技术。当你尝试新东西的时候，你经常需要使用工作记忆来承载这些知识。如果你想把信息从长期记忆中加载到工作记忆中，你还需要练习几遍才行才能熟练这种获取过程。当然重复也有技巧，就是<strong>不要一共100个单词，一天重复一个单词100遍。而是单词分摊开，一天记忆一遍所有单词，第二天依然，持续100天</strong>。所以记忆一个东西，一个下午重复7次，不如每天重复一次来的效果好。把记忆的过程想象成使用胶水，大脑内部的神经元细胞之间需要时间来建立连接，就想胶水需要时间类风干一样。</p>

<p>关键动作：<code>每天重复一点</code></p>

<h2>睡眠</h2>

<p>你也许会惊讶当你知道人醒着的时候我们的大脑会产生毒素！大脑是怎么排除这些毒素的呢？结果是当你睡觉的时候，你的大脑细胞会缩小，然后细胞之间的空隙会变大，这时候液体可以流过这些细胞进而把毒素清洗出去。所以睡眠，在某种意义上来书就是清洗的时间，是大脑保证自身的卫生和健康的方法。所以让我指出关键点，没有休息好就去考试时候，意味着你运行这一个充满神经毒素的大脑。毒素会让你思考不再那么清洗和快速。</p>

<p>睡眠还有另外一个好处，就是在你睡觉的时候，大脑会重复清醒的时候的知识，加强记忆和连接。所以睡眠并不是浪费时间，当然前提是你已经先尝试集中式思考后播下了进行发散式思考的种子。</p>

<p>当你在睡觉以前学习了一些知识，你有很大概率梦见他们。梦见这些东西能提高你理解它们的概率。</p>

<p>关键动作： <code>睡眠</code></p>

<h1>第三章: Chunking &ndash; The Essentials</h1>

<p>这一章讲到了具体的学习方法。首先还是需要搞清楚我们的大脑到底是怎么运作的。上一章只讲了几了两种基本模式，这一章会继续深入——知识的基石块（Chunking）。这一章从学习的质量入手。首先讲到什么是<strong>学习完成幻想症（Illusions of competence in learning）</strong>，第二个大问题是<strong>过度学习（over learning）</strong>。</p>

<h2>什么是思维块（Chunk）？</h2>

<p>首先我们先学习个英文单词——chunk。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>chunk |tʃʌŋk|
</span><span class='line'>noun
</span><span class='line'>①(piece of meat, fruit, bread, etc.)大块
</span><span class='line'>a chunk of plaster
</span><span class='line'>一块厚厚的灰泥
</span><span class='line'>②colloquial (large amount)相当大的量
</span><span class='line'>a fair chunk of the essay
</span><span class='line'>文章的大部分</span></code></pre></td></tr></table></div></figure>


<p>我们来是拿学习一个新概念为例，一般来说当我们接触一些不熟悉的时候，第一反应这些是“什么东西，完全没有感觉呀！”。这些知识点就像一堆散乱的拼图碎块一样，完全意识不到他们拼接起来后会是一幅完整的图画。</p>

<p><img src="" alt="big_picture" /></p>

<p>Chunking就是一种思维跳跃的过程，它可以帮助你把一些信息有条理的聚合起来。新的逻辑会让这些碎片容易理解，更重要的是能把它们联系起来形成一张更大的图片。仅仅记忆一些事实，而不是理解其中上下文不能帮助你理解你正在学习的东西，也不能帮助你理解这些概念和其他概念是怎么联系起来的。注意到这里这块碎片不能和那块相扣，可以帮助你找到其他的碎片是否和这块相扣。</p>

<p>我们前面谈论过我们的短期记忆一般只能记住4件东西。当你集中注意力的时候，就像头顶上有个章鱼，章鱼的有4个触须通过这4个孔来帮助你把分散在大脑各个部分的信息给连接起来。</p>

<p>记住，这和发散式思维中的随机连接是不一样的。集中注意力并尝试去把大脑中的各个部分连接成一个想法是集中式思考学习方法的一个重要组成部分。这也是常用的帮助你建立一个chunck的方法。有趣的是当你处于压制注意力的情况下，脑前的章鱼就开始丧失了连接信息的能力。<strong>这也就是为什么当你处在愤怒、压力或者害怕的时候，大脑不能高效工作的原因。</strong></p>

<p>chunk是一些信息的有机的结合起来形成一个有意义有用的更大片段。比如你可以认识并说出P、O、P这三个字母，并且把他们结合起来形成另外一个有意义的单词pop。这就是一个chunking的过程。</p>

<p>最好的学习语言方式是在集中注意力的状况下的不断重复练习和记忆，同时搭配上自由式的以此语言为母语的朋友对话练习。这样做的目的就是把基本的单词和语法嵌入到脑中，同时放松自由的使用此门语言来创造你自己新语言模块。集中注意力在练习和重复上面，会创造更强的记忆痕迹，这样帮助你创造更多的chunks。通往专家的路是一点一点来的，小的chunks会逐渐变大变成一门专长，并且所有的专长会成为对你成为一名掌握某种本质的大师的基石。总而言之，就像你稍后会看到的，练习和重复的建造chunks并不是你成为某一技能大师的全部，Chunking会帮助你的大脑运转的更加有效。一旦你形成了一个想法，一个概念或者一个动作，你就不需要再记住原来的那些细小的细节了。你已经得到了主题思想——块，那就是足够了。</p>

<p>举个例子，比如你早晨起来穿衣服。你会觉得这是一件很简单的事情。但是出人意料的是当你意识到影藏在这个简单地动作下的一系列活动。</p>

<h2>如何形成chunk？</h2>

<p>我们现在先来介绍一点怎么形成chunk的背景知识。假如你想学习用吉他弹奏一首曲子，而相应的大脑中的神经元表征是一块相当大的块。你会先听这首歌，也许你还会看别人演奏这首曲子，特别是当你还是为初学者的时候，你会学会怎么抱吉他。对于大多数项目和技能来说，获得一个对掌握东西的大体印象的步骤都是相似的。你经常首先抓住一定曲子的片段，并形成一个微小块(mini-chunks)，这个微小块以后会和其他块连接起来形成大块。例如，经过好几天后，你或许已经学会了使用吉他熟练的弹奏一个乐段，而当你掌握很多乐段后，你可以将这些乐段连接起来，逐渐的把所有的段放在一起后你就学会了这首曲子了。</p>

<p>对于学习运动，比如篮球，足球，高尔夫。你先掌握和练习几个片段必要的技能点。这时候你就是在建立微小块，这些微小块日后会渐渐连接成大块，再后你就可以使用这些大块再形成更大、更复杂的块，之后你可以立即使用这些巨大块。比如你可以在踢足球时使用停球技巧，控制朝你轻轻旋转滚来的足球。最好的组块是那些根深蒂固的，你甚至不需要有意识地去将储存在脑中的模式连接起来。而这也正是将复杂的想法，动作和反应，组成一个单独的组块的意义所在。你可以在学习语言时体会到这点，最开始说的一个简单单词，其中的细微差别，语调和口音就已经需要很多的练习了。即兴造句需要有创造力地将新语言中各种复杂的小组块和较大组块联系起来。为了清晰地表达我的意思，试着重复印度卡纳达语的绕口令吧。</p>

<p>Hi，我是Shilpa Knokani。 我的母语是Kannada，这是一种印度最古老的语言之一。今天我们教你一个Kannada的绕口令，来更我读：“Terikere yri male muru kari kurimari meyuthiddavu”。是不是特别简单？（！！！非母语的我们实际表情）。看来除非你是当地人，否则语言只能一点一点学习。</p>

<p>学习数学和科学涉及到同样的方法。当你学习一个新数学或者科学知识时候，通常会先给你一些简单的问题并且附上解答过程。这是因为当你首次尝试理解怎么解答一个问题的时候，你的大脑会产生称重的认知负担。所以这些例子会帮助你起步。这就像你需要先听一首歌然后才能弹奏这首曲子。大多数的解答细节都在这里，而你的工作仅仅是找出到达目的地的路而已。这些例子可以帮助你看清楚问题的关键特征和隐藏的本质。</p>

<p>在使用示例帮助你形成chunks的过程中需要注意一点，那就是这种方法太容易让你集中在一个单独的步骤而不是步骤之间的联系上。这就是为什么下一步你一定要做的关键步骤。所以请铭记于心，这里并没有仅仅教授你“按部就班的做”，仅仅接受指示而不加思考。实际上学习的过程应该更像是使用一张地图来帮你到达一个新地方。集中注意力在将要去的下一个地方，很快你就会找到你自己想要到达的目的地。你甚至可以找出另一条新路径。</p>

<p><strong>接下来我们进入实战环节——形成chunk的具体操作步骤：</strong></p>

<ol>
<li>不要分散注意力，要全神贯注到要关心的事情上</li>
</ol>


<p>不要分散注意力指的是当你开着电视写着作业，或者隔几分钟查看下手机，这样是会大大增加chunk形成的难度。因为你的大脑并没有真正的聚焦在要学习的东西上。当你首次学习某些东西，你正在努力产生一个新模式，这个模式会连接分布在大脑各个地方的已经存在的模式。从前面的关于记忆的章节我们知道，我们的暂存工作空间平均只有4个槽位，所以当你分散精力的时候会占用这些槽。</p>

<ol>
<li>理解基础的思想，不仅仅是独立的块知识，还有这些块之间的<strong>联系</strong>。</li>
</ol>


<p>联系是非常重要的，我们是不是经常有这种感觉，背了无数的英文单词，但是发现确没有办法把他们使用在对话或者写作中？这就是缺少理解他们联系的典型表现。</p>

<p>而且为使得你真正理解所学的内容，请做<strong>练习</strong>。比如你学习一些科学知识的时候，请合上书然后做一些测试。这样会帮你理解问题，同时也会加快你学习的步伐。当你能动手自己做的时候才是你真正理解这些知识的时候。而如果你只是看过，听过，而没有实际做过，就不要指望能真正的吸收容纳成自己的。因为仅仅看过，过着认为自己理解了，并不意味着你可以自己做出来。这个方面我们后面还会涉及，并且有个专业名词——完成幻想。</p>

<p>练习就是帮助你打破这些知识孤岛，把他们联系起来的一个很有效的方法。它会真正的帮你建立chunk之间的联系路径。学习的有梁祝基本的方式——从上到下的方式，从下到上的方式。从下到上的方式指的是你首先学会一些独立的基本块知识，不断的练习知道熟练，并且在需要时候能够轻易使用。然后在尝试着把这些知识都联系起来，形成更多样的用法。比如你学习一首曲子，应该是一个段落一个段落的练习，然后把各个段落连接起来，形成一首完整的歌。而从上到下的学习方式是你首先基本感受一下这方面的整体蓝图。弄清楚它到底有什么用，适用于那些地方。</p>

<p>所以一个基本的学习方法是：在要学习之前首先浏览下整个章节，大概看下要讲什么内容，每个小节会涉及到什么。这样可以帮助你弄清楚知识的基本的概要。就想有了一个大概的地图，让你能很好地组织后面学习的进行。</p>

<p>如果用神经科学的角度来讲，这种方法可以帮助你了解你需要把构建的chunks放在哪里，各个chunk之间有什么关系。</p>

<p>学习某些知识时候，一般都会有关键指示或者书目，或者概念索引等概要知识。你把这些东西找出来后，再往里面填充细节。尽管有些地方可以会被漏掉，你仍然可以知道整个全景是什么样子的。总结起来就是chunks最好在聚精会神、理解基础思想的时候形成。同时练习可以帮助你抓住中心思想。</p>

<p>这就是形成chunk的主要步骤了。</p>

<h2>知识获得假象（Illusions of Competence）</h2>

<p>这章节的内容非常实用，犀利的指出了我们的<strong>无效学习</strong>。这个章节的内容：</p>

<ul>
<li>回放（Recall）</li>
<li>Illusions of Competence</li>
<li>Mini-testing</li>
<li>Value of making mistakes</li>
</ul>


<p>一种常见的学习方法就是重复的读书本和笔记知识。但是根据心理学家——Jeffrey Karpicke表明这种方法通常笔记另一种简单、实用方法低效很多。而这种方法就是<strong>回放（Recall）</strong>，具体指当你读完一段材料后，不要急着读第二遍，而是把书合上是回忆刚才的所读的信息（最好能在纸上画一个大概的结构地图，或者脑图）。</p>

<p>Karpicke的研究发表在《科学旅程》杂志上面，其中有明显的证据表明这种方法非常可行。实验中学生们被要求先学习一段科学知识，然后做些记忆回访练习。这种动作往复几遍。同时对照组使用其他的学习方法，之后的测验结果表明回放的学习方法效果大大好于其他的方法。</p>

<p>其实还有更好的学习方法，那就是合上书本后尝试画出关键知识路径图，弄清楚各个部分的关系。但是这种方法的前提是你已经把基础的知识嵌入到了脑子中，不然效果就不会很好。这就像你学习高级象棋策略，但是之前你连象棋的基本规则都没有弄清楚，显然在你不可能成功。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/09/04/data-file-organization/">Data File Organization</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-09-04T17:01:19+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>4</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>5:01 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content">
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/08/31/introduce-hive/">Introduce Hive</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-08-31T22:57:57+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>31</span><span class='date-suffix'>st</span>, <span class='date-year'>2016</span></span> <span class='time'>10:57 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>Rcfile的设计</h1>

<ul>
<li>key/value</li>
<li>column-store and row-store , why?
row-store: fast loading data in real-time in HDFS, because data coming by row and will be stored in one place event in one block. But it can not support fast ad-hoc query.</li>
</ul>


<p>怎么衡量一个文件组织方式？答案只有一个，那就是它满不满足使用性能？
好的，对于一个文件我们要做的事情无非就是：读，写。
读有又，位置和数据大小的特性。比如按位置划分就有随机读，顺序读，逆序读等等，大小就是读一条数据，一片数据。再把位置和大小一结合，呵呵！是不是很复杂？
对于hive来说，其读特性就是：读一行也行，读一列也快，还有更牛的是还能建立索引。</p>

<p>写的话，也有位置和大小之分。随机写，在头位置写，在未位置写。大小写入一条数据，写入一片数据。再一结合。。。。</p>

<p>hive写的就是追加，这也是为什么要先水平在垂直，要的就是加载数据速度，还有实时加载数据的特性。因为打开一个节点的比打开无数节点靠谱很多不是吗？还往单机上说，就是打开一个文件总比打开多个文件写要快不是吗？
同时如果写操作是流式的，那么每次写入其实都需要重新组织数组块，进行压缩。</p>

<p>如果把读和写结合起来就产生了更邪恶的操作，那就是删除和更新。</p>

<h1>HSQL怎么解析到MapReduce？</h1>

<h2>怎么使用MapReduce实现Join？</h2>

<h2>怎么使用MapReduce实现Group By？</h2>

<h2>怎么使用MapReduce实现Distinct？</h2>

<h1>如何在Hive中加载一个外部的脚本文件？</h1>

<h1>写UDF, UDAF, UDTF</h1>

<p>Hive提供UDF, UDAF, UDTF三种接口来给用户扩展sql的功能。当然为什么要有三个接口呢？他们有什么区别？这个我们下面会依次讲到。</p>

<p>首先我们需要知道现在都有哪些实现好的函数，就不用再造轮子了是吧！</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; show functions;
</span><span class='line'>!  
</span><span class='line'>!=  
</span><span class='line'>......
</span><span class='line'>
</span><span class='line'>&gt; describe function max;</span></code></pre></td></tr></table></div></figure>


<p>show functions这个命令可以列出现有的函数，而describe function function-name会列出具体的函数描述。</p>

<p>写自己的函数前，我们先要明确下我们的函数到底会怎么被Hive运行？会在那个阶段运行？这个就不得不说SQL语句的解析了。一般SQL的解析顺序是：</p>

<ul>
<li>from</li>
<li>on</li>
<li>join</li>
<li>where</li>
<li>group by</li>
<li>having</li>
<li>select</li>
<li>distinct</li>
<li>union</li>
<li>order by</li>
<li>limit</li>
</ul>


<p>本质上SQL是一个种集合代数运算操作的语言，每一种操作都是一种代数操作。
这个顺序基本可以这么理解：首先需要确定数据源（from后面的表），然后数据确定范围（where条件筛选），然后对这个数据进行分组（group），然后选择要展示的列（select），然后可以对选择的数据集进行排序（order by）。后面如果还有一个数据集那么可以union。其中还有像having，distinct和limit操作的顺序我暂时还不能理解这里就不讲了，还有发现distinct的执行顺序和group by并不在一起让而且在select后面，也许这里就会产生一些写法上的注意点。其中这个排序也可能在不同的数据库引擎中执行顺序不一样。
具体详情参看<a href="http://blog.jobbole.com/55086/">这篇文章</a>。</p>

<p>那么hive的函数要做到在SQL语句哪个部分都能运行，所以对函数的语义一定要弄清楚。而且一定要把函数处理过程想想成流式的，因为在SQL中所有的操作都是流式操作。</p>

<ol>
<li>UDF只能实现一进一出的操作, 即UDF只能操作一行的数据，而要操作多行的数据需要使用UDAF实现</li>
<li>实现聚合函数请用UDAF， 解决进多出一</li>
<li>UDTF(User-Defined Table-Generating Functions) 用来解决 输入一行输出多行(On-to-many maping) 的需求</li>
</ol>


<h2>怎么解决hive中的数据倾斜问题</h2>

<h2>hive sql优化</h2>

<ul>
<li>裁剪列，不要写不查的列</li>
<li>裁剪分区，如果是子查询限制条件一般放在子查询内部</li>
<li>Join1 —— 小表前置，想想hash join的过程</li>
<li>Join2 ——</li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/08/22/design-pattern/">Design Pattern</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-08-22T23:00:57+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>22</span><span class='date-suffix'>nd</span>, <span class='date-year'>2016</span></span> <span class='time'>11:00 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content">
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/08/14/how-to-manipulate-binary-stream/">How to Manipulate Binary Stream</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-08-14T20:47:13+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>14</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>8:47 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content">
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/08/14/how-to-use-jmock/">How to Use Jmock</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-08-14T14:35:32+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>14</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>2:35 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.jmock.org/expectations.html">jmock官网</a></p>

<h1>测试框架</h1>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void testSomeAction() {
</span><span class='line'>    ... set up ...
</span><span class='line'>
</span><span class='line'>    context.checking(new Expectations()
</span><span class='line'>        ... expectations go here ...
</span><span class='line'>    );
</span><span class='line'>
</span><span class='line'>    ... code being tested ...
</span><span class='line'>
</span><span class='line'>    context.assertIsSatisfied();
</span><span class='line'>
</span><span class='line'>    ... other assertions ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>其中最重要的一个步骤就是context.checking。这个方法中定义的expectation就是需要关注的。也就是你要模拟的方法的输入和输出。
其他格式是这样的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>invocation-count (mock-object).method(argument-constraints);
</span><span class='line'>    inSequence(sequence-name);
</span><span class='line'>    when(state-machine.is(state-name));
</span><span class='line'>    will(action);
</span><span class='line'>    then(state-machine.is(new-state-name));</span></code></pre></td></tr></table></div></figure>


<p>其每个短语的具体意思如下：</p>

<table>
<thead>
<tr>
<th>one    </th>
<th>The invocation is expected once and once only.</th>
</tr>
</thead>
<tbody>
<tr>
<td>exactly(n).of</td>
<td> The invocation is expected exactly n times. Note: one is a convenient shorthand for exactly(1).</td>
</tr>
<tr>
<td>atLeast(n).of </td>
<td>The invocation is expected at least n times.</td>
</tr>
<tr>
<td>atMost(n).of   </td>
<td>The invocation is expected at most n times.</td>
</tr>
<tr>
<td>between(min, max).of   </td>
<td>The invocation is expected at least min times and at most max times.</td>
</tr>
<tr>
<td>allowing   </td>
<td>The invocation is allowed any number of times but does not have to happen.</td>
</tr>
<tr>
<td>ignoring   </td>
<td>The same as allowing. Allowing or ignoring should be chosen to make the test code clearly express intent.</td>
</tr>
<tr>
<td>never  </td>
<td>The invocation is not expected at all. This is used to make tests more explicit and so easier to understand.</td>
</tr>
</tbody>
</table>


<p>所有的函数都是可以选的，例如你可以如下组合你的exception。</p>

<h1>例子</h1>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void testReturnsCachedObjectWithinTimeout() {
</span><span class='line'>    context.checking(new Expectations()
</span><span class='line'>        oneOf (clock).time(); will(returnValue(loadTime));
</span><span class='line'>        oneOf (clock).time(); will(returnValue(fetchTime));
</span><span class='line'>
</span><span class='line'>        allowing (reloadPolicy).shouldReload(loadTime, fetchTime); will(returnValue(false));
</span><span class='line'>
</span><span class='line'>        oneOf (loader).load(KEY); will(returnValue(VALUE));
</span><span class='line'>    );
</span><span class='line'>
</span><span class='line'>    Object actualValueFromFirstLookup = cache.lookup(KEY);
</span><span class='line'>    Object actualValueFromSecondLookup = cache.lookup(KEY);
</span><span class='line'>
</span><span class='line'>    context.assertIsSatisfied();
</span><span class='line'>    assertSame("should be loaded object", VALUE, actualValueFromFirstLookup);
</span><span class='line'>    assertSame("should be cached object", VALUE, actualValueFromSecondLookup);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/07/29/introduce-cap/">Introduce CAP</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-07-29T10:04:53+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>29</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>10:04 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>这篇博文主要是对<a href="http://www.infoq.com/cn/articles/cap-twelve-years-later-how-the-rules-have-changed/">《CAP理论十二年回顾："规则"变了》</a>的读后感。</p>

<h1>CAP到底讲什么，为什么不能同时满足？</h1>

<p>首先明确一点，CAP是一个分布式系统的特性，如果你没有多个服务节点，就不可能发生分区。先解释下概念：
- C —— 执行的结果能同时反映到所有节点上。等同于所有节点访问同一份最新的数据副本。也许这里需要很多的具体不变性约束，比如主键不能重复。
- A —— 这个是指访问的节点是正常的，那么就能正常执行请求（所以和P的一个冲突点就是当系统部分失效，这个系统到底是判定为失效还是正常？）
- P —— 这个特性是说当系统的节点之间通信出现了问题，导致之间不能同步，然后还能继续提供服务。
其实我第一次读这个概念，就是不明白为啥这三个方面不能全部同时获得。然后看了个这个例子：</p>

<blockquote><p>理解CAP理论的最简单方式是想象两个节点分处分区两侧。允许至少一个节点更新状态会导致数据不一致，即丧失了C性质。如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了A性质。除非两个节点可以互相通信，才能既保证C又保证A，这又会导致丧失P性质。一般来说跨区域的系统，设计师无法舍弃P性质，那么就只能在数据一致性和可用性上做一个艰难选择。不确切地说，NoSQL运动的主题其实是创造各种可用性优先、数据一致性其次的方案；而传统数据库坚守ACID特性（原子性、一致性、隔离性、持久性），做的是相反的事情。下文“ACID、BASE、CAP”小节详细说明了它们的差异。</p></blockquote>

<p>上面的例子说的太清楚了，当分布式系统发生了节点之间通信失败，就相当于一个整体的服务发生断裂，分成了几个服务块。从而丢失了其对等性（即从任意一个节点都可以访问到整个系统）。然后这个时候如果其中一部分提供服务，比如写操作通过一节点写入了，但是因为不能通信没有办法复制到其他节点，导致了系统的不一致性。这样就就丢失了C，但是还好保住了A。
接着如果要追求C，那么只有等节点之间的通信成功才行，那么就需要写入操作延迟或者这个期间拒绝服务。那么都不能服务了，自然就没有了A。</p>

<p>所以来说当没有发生分区的时候，C和A可以完美保持。但是发生了分区，那么要容错，C和A可能就不能同时保持。
其实这不是一个3选2的问题，因为你没办法选择系统不分区，当通信出问题这个是能选择的吗？这个是故障，你有办法选择故障？所以其实所有的分布式系统都是在C和A之间进行设计权责。</p>

<h1>C和A之间选择不是0和1的选择，而是一种连续式选择</h1>

<p>从上面的例子看，好像选择C就必须放弃A，反之亦然。但是其实所有这些都有中间方案。C和A的定义也有各种灰度定义。
比如C的定义，最严格的定义就是一个分布式事务结束后，所有的副本在任何时刻都是一致的。但是这个定义可以放宽。时间不在是同时，而是一段时间，给一个时间窗口。或者一阶段内可以不一致，但最终变成一致的。比如上面的例子中，在发生分区的时候，可以暂时不一致，等到通信问题解决了，开始恢复一致性。</p>

<p>而对于A的定义来说，也是有各种层次，在发生分区的时候，可以选择限制部分操作，同时提供一个些事后比较好恢复的操作。</p>

<h1>一种经典的系统设计模式</h1>

<p>因为在分布式系统中，基本是没有办法选择不要分区的，所以为了保证系统的可用性，和一致性的博弈，经典的设计模式就是分情况对待。当不发生分区的时候保证完美的CA，到出现了分区，进入分区模式，等待分区恢复后，恢复系统，最终达到一致性后，再次进入完美CA状态。</p>

<p><img src="../images/posts/CAP1.png" alt="" /></p>

<ul>
<li>检测到分区开始</li>
<li>明确进入分区模式，限制某些操作，并且</li>
<li>当通信恢复后启动分区恢复过程</li>
</ul>


<p>最后一步的目的是恢复一致性，以及补偿在系统分区期间程序产生的错误。</p>

<p>当系统进入到分区模式，它有两种可行的策略。其一是限制部分操作，因此会削弱可用性。其二是额外记录一些有利于后面分区恢复的操作信息。系统可通过持续尝试恢复通信来察觉分区何时结束。</p>

<h1>副本</h1>

<p>一谈到副本，最大的问题就是其一致性，这个问题不仅仅是在分布式系统中涉及，只不过分布式系统是鼓励副本的存在，而在这个基础上开始设计一套一套的解决方案。但相对其他领域——比如设计模式OOD，关系数据范式都是从另一个方向把<strong>重复（副本）扼杀在摇篮中</strong>，比如策略模型，把能公用的都抽象出来复用。</p>

<h1>可怕的一致性</h1>

<ol>
<li>一个场景，一个问题</li>
<li>如何解决这个问题？</li>
<li>这个解决方法是错的吗？</li>
<li>这个方法是对的吗？</li>
<li><p>有没有更优的解法？</p></li>
<li><p>隐喻，一个直观的例子</p></li>
<li>过度到实际的模型</li>
<li>证明模型</li>
<li>实际用途</li>
</ol>


<h1>reference</h1>

<ul>
<li><a href="https://martin.kleppmann.com/2015/05/11/please-stop-calling-databases-cp-or-ap.html">Please stop calling databases CP or AP</a></li>
<li><a href="https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed">CAP Twelve Years Later: How the &ldquo;Rules&rdquo; Have Changed
</a></li>
<li><a href="http://www.cnblogs.com/esingchan/p/3917718.html">分布式理论之一：Paxos算法的通俗理解</a></li>
<li><a href="http://www.cnblogs.com/endsock/p/3480093.html">Paxos算法细节详解(一)&ndash;通过现实世界描述算法</a></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/07/24/how-to-understand-a-database/">如何理解一个数据存储系统</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-07-24T14:57:42+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>24</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>2:57 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>储存系统的目的</h1>

<p>其实储存系统的目的估计和文件系统没什么两样，就是存储数据并且取出数据。关键的两个操作还是 <strong>write/read</strong>。但是说差异巨大也是合理的，因为因为文件系统的是面向<strong>文件</strong>的，而对数据的结构和信息是隐藏起来，可以说毫不关心数据的特质，全部打包放在一起。而数据储存系统而转换了问题的角度，把主角换成了<strong>数据</strong>，提供数据的特定的组织方式，针对不同结果的组织给出方便的获取和写入方式。</p>

<p>说明其不同，让我们看一个例子。拿最常数的用户表说明，如果我们建立的一个网站，提供用户注册留言。
设想我们没有数据库，只能存储文件，那么我们就会这么存储：</p>

<blockquote><p>user.txt
|user_id | name | phone|
|&mdash;&mdash;&ndash;|&mdash;&mdash;|&mdash;&mdash;|
|001     |Alice |123333|
|002     |Bob   |166666|
|&hellip;     |&hellip;   |&hellip;   |</p>

<p>message.txt
|user_id | message|
|&mdash;&mdash;&ndash;|&mdash;&mdash;&ndash;|
|001     |I am Alice|
|002     |I am Bob|
|&hellip;     |&hellip;   |</p></blockquote>

<p>这时候一个用户查看自己发送过的所有的留言。首先做的是从uesr.txt中扫描，找出Alice的user_id信息，然后再在message.txt找出所有的留言。这个过程估计需要你不短的一段代码。跟别提还要各种分割字符串，切出各种字段。还有更难控制的字段的类型，比如日期格式等。</p>

<p>而上面的通用常见的问题，通过数据库系统得到了很好的解决。</p>

<h1>模型层次</h1>

<p>既然说了数据库的目的，那么就来看看怎么构建一个数据库。先看下面的图，描述了数据库的使用层次和实际实现层次。使用层次就是面向用户（程序员），说明系统张什么样子的。而实现层次就是为了支持使用层次而设计的实现方法。使用更专业的术语那就是逻辑层次一个是物理层次。</p>

<p><img src="http://woodcarver.oss-cn-shanghai.aliyuncs.com/post/data_system.png" alt="dddd" /></p>

<p>逻辑层次就是开发者看到的、理解的、认为的样子。对于这层来说大部分数据引擎其实都差不多，不是关系型的就是key-value型。当不了解引擎内部的物理实现逻辑的时候，用户肯定会按照自己理所当然的想法去使用这个系统。这个想法无可厚非，能做到让用户安全放心的使用，尽量屏蔽底层实现也是数据管理系统的追求。不过现在看来当你的数据大一点的时候这个想法有点不现实。</p>

<p>所以如果还不关注其内部实现，就会不断出现红框框的问题，知道你放弃这个系统为止。</p>

<p>但是如果你开始理解其物理层次的机制后，会对逻辑层次有更深入的理解，一些问题也能迎刃而解。</p>

<h1>当谈起一个数据库的时候，我们在说什么？</h1>

<p>两个方面，了解其逻辑模型和物理模型。既然逻辑模型都一样或者差不多，为什么还需要不同的物理模型？原因就没有哪种数据库能支持各种操作到极致的，每种数据库都各种操作都有取舍，各有优缺。有些支持快速的响应，例如redis，有些偏向于？？？？？。</p>

<h2>谈逻辑模型——提供什么服务，支持哪些操作</h2>

<p>两大数据模型 —— 关系型数据模型、key-value数据模型
都支持add、delete、select和update。不过具体支持的方向不同，而不同关键点在<strong>位置</strong>和<strong>范围</strong>的不同。</p>

<ul>
<li>关系型数据模型：基本模型是一个张二维表。

<ul>
<li>add：在表的尾部添加即可。</li>
<li>delete：查找到位置，然后删除。</li>
<li>select：全表扫描，或者利用索引技术。</li>
<li>update：查找到位置，然后更新。</li>
<li>没有递归结构，导致对嵌套数据储存不友好。需要大量的冗余数据。</li>
</ul>
</li>
<li>key-value数据模型

<ul>
<li>add：利用hash funciton后找到其位置，然后添加。</li>
<li>delete：查找到位置，然后删除。</li>
<li>select：利用hash定位。</li>
<li>update：查找到位置，然后更新。</li>
<li>天然的递归结构，对嵌套结构支持友好方便。</li>
</ul>
</li>
</ul>


<p>因为几乎所有的操作都和查找有关，其中查找的效率能直接决定系统的效率。关系型数据库的查找效率(一条数据)要么是O(n)要么是O(logn)，让然也可以是O(1)，以为可以有hash索引。而key-value的查找效率是O(1)。</p>

<h2>谈物理层次——怎么实现这些操作的？如何组合才能最大的发挥其性能？</h2>

<p>物理层次出了决定操作的性能外，还有一个重大的不同，就是对规模扩展的支持程度有巨大的差别。关系型数据库的一个诟病就是对规模扩展非常差。其优良的操作模型和结构化数据要求进一步对大数据量的日志型提出了挑战。</p>

<h2>一个表现的具体问题，<a href="http://stackoverflow.com/questions/1636379/why-db-indexes-use-balanced-trees-not-hashtables">Why DB indexes use balanced trees, not hashtables?</a></h2>

<h2>Has different Characteristics for data operatings</h2>

<p>B-Tree supports comparisons  =, >, >=, &lt;, &lt;=, BETWEEN operators and like, while HashTable only supports =.
so the using scope of HashTable is too narrow.</p>

<h2>HashTable is hard to rescale or grow</h2>

<p>The size of hashtable is determined when it is created. If you add more data than it&rsquo;s size, you need to resize it. And it&rsquo;s very ineffcient. althought there are rescale algorithm or other replication policy(like in redis).</p>

<h2>memory usage effiency</h2>

<p>B+ Tree can be load into memory partially, while HashTable can not. ?? really?</p>

<h2>refernece</h2>

<ol>
<li><a href="https://dev.mysql.com/doc/refman/5.5/en/index-btree-hash.html">Comparison of B-Tree and Hash Indexes</a></li>
</ol>


<h1>reference</h1>

<ul>
<li><a href="https://www.tutorialcup.com/dbms/data-independence.htm">Data Independence</a></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/07/20/why-need-runnable-while-we-already-have-thread-in-java/">java里为什么有了Thread还要设置一个Runnable？</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-07-20T21:36:45+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>20</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>9:36 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>我学习多线程疑惑，为什么会有这种代码出现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nf">Runnable</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>               <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;this is a runnable&quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">);</span>
</span><span class='line'>    <span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>不是有个更简便的方法吗？</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Thread</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;this is a thread&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">};</span>
</span><span class='line'><span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>虽然很容易知道Runnable是个接口，而Thread是Runnable的一个具体实现。但是既然concurrent包中只有Thread一个类实现，那些Runnable这个接口到底有什么用？
答案就是用户可能会使用到多类继承，但是这在java中是禁止，只能用interface实现。比如我想设计一个任务队列，然后这个任务可以随时开启一个线程运行。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">class</span> <span class="nc">TaskQueue</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">Runnable</span> <span class="o">{</span>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">//...</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/07/18/the-world-about-oriental-column-database/">数据分析利器 —— 列式储存数据库</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-07-18T11:00:26+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>18</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>11:00 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1><a href="https://en.wikipedia.org/wiki/Column-oriented_database">列式数据库</a></h1>

<p>什么是列式数据库？可能大家也才到了，既然有列式数据库，那么肯定就有行式的喽！确实是这样的。也许大多数人并不了解数据库储存模型（storage model 即physical schema）和数据库的数据模型（data model 也叫 logical schema），不过对上层是使用者也没多大关系。不过我们现在讲的列式和行式就是指数据库的storage model，而他们支持同样的data schema，即对data model感知不到storage model的实现区别。
一个数据库的data model约定可以进行上层数据操作，而storage model决定这些操作的性能。比如，No Sql数据库使用的是data model都是key-value，而储存模型有map结构实现，也可以由tree结构实现。而对于sql数据库，其数据模型是一张二维表，而至于怎么存储这张二维表，很容易就可以想到可以按行存储和按列储存。按行存储就是我们现在常见操作型数据库，而是最大众的数据库，比如MySql、Oracle、……等等你所知道大部分数据库。而按列储存的数据库现在也是很有名，比如Hive、Vertica、Druid、Infobright等。</p>

<h1>为什么要行式数据库又要列式数据库？</h1>

<p>先让让我们想象关于二维表我们有哪些操作？—— select、update、delete和insert。这些操作都会需要找到相应的位置，所以这些操作的基础都是search。
而基本的算法都是即从时间考虑也是从空间考虑的。我们开始具体举个例子。</p>

<p>在数据库储存作为实际的一堆储存在磁盘上的文件，在设计不得不考虑磁盘的特性。一般的磁盘特性，其实所有的储存都有一个特性就是对于locality良好的存取性能是随机存取的好几倍。我们现在把一块想像成一组固定大小的块，如图： disk logic model 而文件的内容实际会被分开按照磁盘逻辑块来储存，数据库主要任务就是怎么组织这些逻辑块来取得更好的读取性能和便捷性。
<img src="../images/posts/disk_block.png" alt="" /></p>

<p>在不考虑索引的情况下，所有的磁盘读取都是顺序读取，这意味了要查找一个东西，都需要扫描全表或者部分表。很直观的道理，读取的性能就是取决于扫描的范围。范围越大，速度当然越慢。
我们先假设我们有一堆如下的数据：</p>

<table>
<thead>
<tr>
<th>RowId</th>
<th>EmpId  </th>
<th>Lastname  </th>
<th>Firstname</th>
<th> Salary</th>
</tr>
</thead>
<tbody>
<tr>
<td>001  </td>
<td>10    </td>
<td>Smith     </td>
<td>Joe     </td>
<td>40000</td>
</tr>
<tr>
<td>002  </td>
<td>12    </td>
<td>Jones     </td>
<td>Mary    </td>
<td>50000</td>
</tr>
<tr>
<td>003  </td>
<td>11    </td>
<td>Johnson   </td>
<td>Cathy   </td>
<td>44000</td>
</tr>
<tr>
<td>004  </td>
<td>22    </td>
<td>Jones     </td>
<td>Bob     </td>
<td>55000</td>
</tr>
</tbody>
</table>


<h2>行式储存模型</h2>

<p>好现在我们开始让磁盘里塞，假设我们的磁盘块只能容下5个字段（抽象的，假设我们的这些字段的大小都一样），因为我们是按找行优先的，所以结果就如下：
<img src="../images/posts/row_oriented.png" alt="row oriented model" /></p>

<p>于是当我们要找Jones的所有信息的工资时候，我们会依次从第一块磁盘块直到扫描到最后（为什么要扫到最后，因为是在找全部叫Jones的信息，所以不扫都最后都不能确定是否会遗漏）。一共需要扫4块，然后取出其第二块和第四块信息，找出其工资的信息。</p>

<p>其实基于行式储存，对于where语句处理都需要处理全表。对于磁盘的不停seek，速度就可想而知。当然一般数据库为了应对这种全数据扫描，找到了建立索引的方法。而索引就是对某个或者某些字段的组合的信息，即取出数据的部分信息，以减少每次扫描从全表到部分信息的扫描的过渡。</p>

<p>这种查询方式很适合于一次取出一个行数据，而对于日常应用系统来说这种方式是非常合适的，因为我们设计应用的时候都是针对一个事务，而我们会把一个事务所有属性存储成一行，使用的时候也是有很大的概率涉及到整行的信息，很利于做缓存。还比如我们经常使用的那些经典sql 语句：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="k">user</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1001</span><span class="p">;</span>
</span><span class='line'><span class="k">select</span> <span class="n">id</span><span class="p">,</span> <span class="n">user_name</span><span class="p">,</span> <span class="n">email</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">gender</span><span class="p">,</span> <span class="p">...</span> <span class="k">from</span> <span class="k">user</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1001</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>！！还敢不敢列出些更多的字段！！</p>

<h2>列式储存模型</h2>

<p>而列储存就是下图这种按列优先储存。为了方便我们每块只储存了一个一列，没有存满。
<img src="../images/posts/column_oriented.png" alt="row oriented model" />
这下我们再考虑上面的查找所有Jones的工资，这下我们只扫描第三个磁盘块，找出Jones都再那些行，然后根据查出来的行号，直接去第五块磁盘（这块对应的式salary列）找出第二、四行的数据，然后输出。一共2次seek。大大小于row－oriented的4次。</p>

<p>这种查询方式的前提就是你就需要这列数据就行了，其前提假设就是查询基本不会使用这个行的其他列数据。显然这种假设对于日常操作系统的围绕着一个主题进行的活动是不合适旳。但是却在分析型数据大显身手。</p>

<p>列式的另一大优势是压缩。因为列的天然凝聚性（比如上面的两个Jones就可以压缩成一个）大大强与行，所以列式储存可以有很高的压缩比，这个进一步使使用的磁盘的数量减少，因为使用的磁盘块少，进一步减少了需要扫描的次数。这方面很利于加快查找速度，但是因为解压缩也是耗时耗内存的过程，所以压缩的控制也是需要一个定平衡点。</p>

<h1>优劣总结</h1>

<p>从上面的例子可以明显看出列式数据库在分析需求（获取特点——每次查询几个维度，通常是）时候，不仅<strong>搜索时间效率</strong>占优势，其<strong>空间效率</strong>也是很明显的。特别是针对动辄按T计算的数据量来说，在分布式环境中能进行压缩处理能节省宝贵的内部带宽，从而提高整个计算任务性能。</p>

<p>关于行式和列式的具体优缺点还有具体的使用场景请看wikipedia。</p>

<h1>再来谈谈储存模型</h1>

<p>从上面看，改变物理储存结构对上层操作效率的提高是如此的巨大！所以我们再深入谈谈这个话题。</p>

<p>在数据模型一定的情况下，储存模型也是有多种选择的（想想各种不同数据结构居然提供同样的操作，比如TreeMap和HashMap。数据模型好比Map支持getKey和getValue。而储存模型就是Tree还是HashTable，而getKey和getValue操作虽然对使用者没有区别，但是底层的组织结构则决定了其效率）。而储存模型在数据库这种复杂系统中有分好多层。我们想想先从最底层说起——文件，数据终归都是储存在磁盘上的。而从下面的表格看出，数据要取出必须先进入到内存，那么这个层次的核心就是面对各种查询、写入、更新和删除，怎么快速把数据从磁盘加载到内存中或者反之怎么把数据从内存中快速的写入到磁盘中。</p>

<table>
<thead>
<tr>
<th>用户界面</th>
</tr>
</thead>
<tbody>
<tr>
<td>内存    </td>
</tr>
<tr>
<td>磁盘    </td>
</tr>
</tbody>
</table>


<p>所以先谈谈文件储存有哪些类型：<a href="https://www.tutorialcup.com/dbms/file-organization.htm">File Organization in DBMS</a> 这篇文章对于文件组织在DBMS中的意义讲的非常清楚。这里引出其中对文件组织的要点：</p>

<blockquote><p>Storing the files in certain order is called file organization. The main objective of file organization is</p>

<ul>
<li>Optimal selection of records i.e.; records should be accessed as fast as possible. &ndash; 支持快速的获取</li>
<li>Any insert, update or delete transaction on records should be easy, quick and should not harm other records. &ndash; 支持快读的插入、更新和删除事务</li>
<li>No duplicate records should be induced as a result of insert, update or delete &ndash; 支持键值不重复？？？</li>
<li>Records should be stored efficiently so that cost of storage is minimal. &ndash; 储存占用磁盘空间要小</li>
</ul>
</blockquote>

<p>从上面的目的看，大多数不能同时满足，这样就出现了各种各样的组合选择，所以出现多种组织方式：</p>

<ul>
<li>Sequential File Organization</li>
<li>Heap File Organization</li>
<li>Hash/Direct File Organization</li>
<li>Indexed Sequential Access Method</li>
<li>B+ Tree File Organization</li>
<li>Cluster File Organization
Let us see one by one on clicking the above links</li>
</ul>


<p>Difference between Sequential, heap/Direct, Hash, ISAM, B+ Tree, Cluster file organization in database management system (DBMS) as shown below:</p>

<table>
<thead>
<tr>
<th>          </th>
<th>Sequential</th>
<th> Heap/Direct</th>
<th>Hash </th>
<th>ISAM </th>
<th>B+ tree</th>
<th>Cluster</th>
</tr>
</thead>
<tbody>
<tr>
<td>Method of storing </td>
<td>Stored as they come or sorted as they come </td>
<td>Stored at the end of the file. But the address in the memory is random. </td>
<td>Stored at the hash address generated</td>
<td>Address index is appended to the record </td>
<td>Stored in a tree like structure </td>
<td>Frequently joined tables are clubbed into one file based on cluster key</td>
</tr>
<tr>
<td>疑问</td>
<td>如何做到删除的？</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Types </td>
<td>Pile file and sorted file Method </td>
<td> </td>
<td>Static and dynamic hashing </td>
<td> Dense, Sparse, multilevel </td>
<td>indexing </td>
<td>Indexed and Hash</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Design</td>
<td>Simple Design</td>
<td>Simplest</td>
<td>Medium</td>
<td>Complex</td>
<td>Complex</td>
<td>Simple</td>
</tr>
<tr>
<td>Storage Cost</td>
<td>Cheap (magnetic tapes)</td>
<td>Cheap</td>
<td>Medium</td>
<td>Costlier</td>
<td>Costlier</td>
<td>Medium</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Advantage </td>
<td>Fast and efficient when there is large volumes of data, Report generation, statistical calculations etc</td>
<td>  Best suited for bulk insertion, and small files/tables</td>
<td>Faster Access,No Need to Sort,Handles multiple transactions,Suitable for Online transactions</td>
<td> Searching records is faster.Suitable for large database.Any of the columns can be used as key column.Searching range of data &amp; partial data are efficient.</td>
<td> Searching range of data &amp; partial data are efficient.No performance degrades when there is insert / delete / update.Grows and shrinks with data.Works well in secondary storage devices and hence reducing disk I/O.Since all datas are at the leaf node, searching is easy.All data at leaf node are sorted sequential linked list.</td>
<td>Best suited for frequently joined tables.Suitable for 1:M mappings</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Disadvantage </td>
<td>Sorting of data each time for insert/delete/ update takes time and makes system slow.  </td>
<td>Records are scattered in the memory and they are inefficiently used. Hence increases the memory size.  Proper memory management is needed.  Not suitable for large tables. </td>
<td>Accidental Deletion or updation of Data. Use of Memory is inefficient Searching range of data, partial data, non-hash key column, searching single hash column when multiple hash keys present or frequently updated column as hash key are inefficient. </td>
<td>Extra cost to maintain index. File reconstruction is needed as insert/update/delete.Does not grow with data.  </td>
<td>Not suitable for static tables  </td>
<td>Not suitable for large database. Suitable only for the joins on which clustering is done. Less frequently used joins and 1: 1 Mapping are inefficient.</td>
</tr>
</tbody>
</table>


<h1>refernce</h1>

<ul>
<li><a href="https://www.tutorialcup.com/dbms/file-organization.htm">File Organization in DBMS</a></li>
<li><a href="https://en.wikipedia.org/wiki/Database_storage_structures">Database storage structures</a></li>
<li><a href="http://blog.csdn.net/cjfeii/article/details/8884658">关系型数据在磁盘上的存储布局</a></li>
<li><a href="http://blog.csdn.net/v_july_v/article/details/7526689">从LSM-Tree、COLA-Tree谈到StackOverflow、OSQA</a></li>
<li><a href="http://www.cnblogs.com/siegfang/archive/2013/01/12/lsm-tree.html">日志结构的合并树 The Log-Structured Merge-Tree</a></li>
</ul>

</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/2">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/09/14/learning-how-to-learn/">Learning How to Learn</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/09/04/data-file-organization/">Data File Organization</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/08/31/introduce-hive/">Introduce Hive</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/08/22/design-pattern/">Design Pattern</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/08/14/how-to-manipulate-binary-stream/">How to Manipulate Binary Stream</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - Wood Carver -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
